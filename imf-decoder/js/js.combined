// types/wasm.d.ts
declare module '*.wasm' {
  const content: WebAssembly.Module;
  export default content;
}



declare module '@pkg/imf_decoder' {
  export class IMFDecoder {
      constructor(width: number, height: number);
      test(): string;
      diagnostic_mode: boolean;
      set_reference_data(data: any): Promise<string>;
      process_tokens(tokens: any): Promise<string>;
      process_batch(): Promise<string>;
      get_reference_status(): string;
  }

  export function start(): void;
  export default function init(): Promise<void>;
}

// types/index.ts
// js/types/index.ts

// Enums
export enum PlayerStatus {
  Idle = 0,
  Ready = 1,
  Playing = 2,
  Pause = 3,
  Destroyed = 4
}

export enum DecoderStatus {
  Idle = 0,
  Initializing = 1,
  Ready = 2,
  Open = 3,
  Pause = 4,
  Closed = 5
}

export enum MessageType {
  DecoderCreated = 'DecoderCreated',
  DecoderInit = 'DecoderInit',
  DecoderInited = 'DecoderInited',
  WasmLoaded = 'WasmLoaded',
  DecoderReady = 'DecoderReady',
  ReferenceDataSet = 'ReferenceDataSet',
  TokensProcessed = 'TokensProcessed',
  BatchProcessed = 'BatchProcessed',
  Error = 'Error'
}

// Configuration Interfaces
export interface DecoderConfig {
  width: number;
  height: number;
  maxQueueSize?: number;
  batchSize?: number;
}

// Data Structure Interfaces 
export interface ReferenceFeature {
  tensor: Float32Array;
  shape: number[];
}

export interface ReferenceData {
  features: ReferenceFeature[];
  token: Float32Array;
}

export interface FrameToken {
  token: Float32Array;
  frame_index: number;
}

// WASM Related Interfaces
export interface WasmModule {
  IMFDecoder: new (width: number, height: number) => IMFDecoder;
  default: () => Promise<void>;
  [key: string]: any;
}

export interface IMFDecoder {
  test: () => string;
  diagnostic_mode: boolean;
  set_reference_data: (data: ReferenceData) => Promise<string>;
  process_tokens: (tokens: FrameToken[]) => Promise<string>;
  process_batch: () => Promise<string>;
  get_reference_status: () => string;
}

// Result Interfaces
export interface VerifyResult {
  success: boolean;
  module?: WasmModule;
  decoder?: IMFDecoder;
  error?: Error;
}

export interface TestResult {
  success: boolean;
  message?: string;
  error?: string;
}

// Worker Message Interface
export interface WorkerMessage {
  type: MessageType;
  data?: any;
  error?: string;
}

// decoder/player.ts
import * as tf from '@tensorflow/tfjs';
import { 
    PlayerStatus, 
    MessageType, 
    DecoderConfig,
    WorkerMessage, 
    ReferenceData 
} from '../types';

export class IMFPlayer {
    private worker: Worker;
    private status: PlayerStatus = PlayerStatus.Idle;
    private model: tf.GraphModel | null = null;
    private callbacks: Map<MessageType, Function>;
    private config: DecoderConfig;

    constructor(config: DecoderConfig) {
        this.config = config;
        this.callbacks = new Map();
        this.worker = new Worker(new URL('./decoder.worker.ts', import.meta.url));
        this.setupWorkerListeners();
    }

    private setupWorkerListeners() {
        this.worker.onmessage = (event: MessageEvent<WorkerMessage>) => {
            const { type, data, error } = event.data;
            
            const callback = this.callbacks.get(type);
            if (callback) {
                callback(data);
                this.callbacks.delete(type);
            }

            if (error) {
                console.error('Decoder error:', error);
                return;
            }

            switch (type) {
                case MessageType.DecoderCreated:
                    this.status = PlayerStatus.Ready;
                    break;
                // Add other message handlers
            }
        };
    }

    async initialize(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.callbacks.set(MessageType.DecoderInited, resolve);
            this.worker.postMessage({ 
                type: MessageType.DecoderInit,
                data: this.config
            });
        });
    }

    async loadModel(modelUrl: string): Promise<boolean> {
        try {
            this.model = await tf.loadGraphModel(modelUrl);
            const referenceData = this.createReferenceData();
            
            return new Promise((resolve) => {
                this.callbacks.set(MessageType.ReferenceDataSet, (status: boolean) => {
                    resolve(status);
                });

                this.worker.postMessage({
                    type: MessageType.DecoderInit,
                    data: referenceData
                });
            });
        } catch (error) {
            console.error('Failed to load model:', error);
            return false;
        }
    }

    private createReferenceData(): ReferenceData {
        // Create reference tensors
        const features = [
            tf.zeros([1, 128, 64, 64]),
            tf.zeros([1, 256, 32, 32]),
            tf.zeros([1, 512, 16, 16]),
            tf.zeros([1, 512, 8, 8])
        ];

        const token = tf.zeros([1, 32]);

        // Convert to the format expected by the decoder
        return {
            features: features.map(tensor => ({
                tensor: tensor.dataSync() as Float32Array,
                shape: tensor.shape
            })),
            token: token.dataSync() as Float32Array
        };
    }

    async processFrame(inputData: Float32Array, inputShape: number[]): Promise<void> {
        if (!this.model || this.status !== PlayerStatus.Playing) {
            return;
        }

        try {
            const inputTensor = tf.tensor(inputData, inputShape);
            const outputTensor = await this.model.executeAsync(inputTensor);
            const outputData = await (outputTensor as tf.Tensor).data();

            return new Promise((resolve) => {
                this.callbacks.set(MessageType.TokensProcessed, resolve);
                
                this.worker.postMessage({
                    type: MessageType.TokensProcessed,
                    data: [{
                        token: Array.from(outputData),
                        frame_index: 0
                    }]
                });
            });
        } catch (error) {
            console.error('Error processing frame:', error);
            throw error;
        }
    }

    destroy() {
        if (this.model) {
            this.model.dispose();
        }
        this.worker.terminate();
        this.status = PlayerStatus.Destroyed;
    }
}

// decoder/decoder.ts
import * as tf from '@tensorflow/tfjs';
import { PlayerStatus, MessageType, ReferenceData } from '../types';

export class IMFPlayer {
    private worker: Worker;
    private status: PlayerStatus = PlayerStatus.Idle;
    private model: tf.GraphModel | null = null;
    private callbacks: Map<string, Function> = new Map();

    constructor(width: number, height: number) {
        this.worker = new Worker(new URL('./decoder.worker', import.meta.url));
        this.setupWorkerListeners();
    }

    private setupWorkerListeners() {
        this.worker.onmessage = (event) => {
            const { type, data, error } = event.data;
            
            const callback = this.callbacks.get(type);
            if (callback) {
                callback(data);
                this.callbacks.delete(type);
            }

            switch (type as MessageType) {
                case MessageType.DecoderCreated:
                    this.status = PlayerStatus.Ready;
                    break;
                case MessageType.Error:
                    console.error('Decoder error:', error);
                    break;
            }
        };
    }

    async initialize(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.callbacks.set(MessageType.DecoderInited, resolve);
            this.worker.postMessage({ type: MessageType.DecoderInit });
        });
    }

    async loadModel(modelUrl: string): Promise<boolean> {
        try {
            this.model = await tf.loadGraphModel(modelUrl);
            const referenceData = this.createReferenceData();
            
            return new Promise((resolve, reject) => {
                this.callbacks.set(MessageType.ReferenceDataSet, (status: boolean) => {
                    resolve(status);
                });

                this.worker.postMessage({
                    type: MessageType.DecoderInit,
                    data: referenceData
                });
            });
        } catch (error) {
            console.error('Failed to load model:', error);
            return false;
        }
    }

    private createReferenceData(): ReferenceData {
        const features = [
            tf.zeros([1, 128, 64, 64]),
            tf.zeros([1, 256, 32, 32]),
            tf.zeros([1, 512, 16, 16]),
            tf.zeros([1, 512, 8, 8])
        ];
        const token = tf.zeros([1, 32]);

        return {
            features: features.map(tensor => ({
                tensor: tensor.dataSync() as Float32Array,
                shape: tensor.shape
            })),
            token: token.dataSync() as Float32Array
        };
    }

    async processFrame(inputData: Float32Array, inputShape: number[]): Promise<void> {
        if (!this.model) return;

        try {
            const inputTensor = tf.tensor(inputData, inputShape);
            const outputTensor = await this.model.executeAsync(inputTensor);
            const outputData = await (outputTensor as tf.Tensor).data();

            return new Promise((resolve) => {
                this.callbacks.set(MessageType.TokensProcessed, resolve);
                
                this.worker.postMessage({
                    type: MessageType.TokensProcessed,
                    data: [{
                        token: Array.from(outputData),
                        frame_index: 0
                    }]
                });
            });
        } catch (error) {
            console.error('Error processing frame:', error);
        }
    }

    destroy() {
        if (this.model) {
            this.model.dispose();
        }
        this.worker.terminate();
        this.status = PlayerStatus.Destroyed;
    }
}


// decoder/worker.ts
// js/decoder/worker.ts
import init, { IMFDecoder } from '../../pkg/imf_decoder';
import { MessageType, DecoderStatus } from '../types';

class DecoderWorkerInstance {
    private decoder: IMFDecoder | null = null;
    private status: DecoderStatus = DecoderStatus.Idle;

    async initialize() {
        try {
            await init();
            this.decoder = new IMFDecoder(1920, 1080);
            this.status = DecoderStatus.Ready;
            self.postMessage({ type: MessageType.DecoderCreated });
        } catch (error) {
            self.postMessage({ 
                type: MessageType.Error, 
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }

    handleMessage(event: MessageEvent) {
        const { type, data } = event.data;

        try {
            switch (type as MessageType) {
                case MessageType.DecoderInit:
                    this.initialize();
                    break;
                case MessageType.TokensProcessed:
                    this.processTokens(data);
                    break;
            }
        } catch (error) {
            self.postMessage({ 
                type: MessageType.Error, 
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }

    async processTokens(tokens: any) {
        if (!this.decoder || this.status !== DecoderStatus.Ready) {
            throw new Error('Decoder not ready');
        }

        const result = await this.decoder.process_tokens(tokens);
        self.postMessage({ type: MessageType.TokensProcessed, result });

        const batchResult = await this.decoder.process_batch();
        self.postMessage({ type: MessageType.BatchProcessed, result: batchResult });
    }
}

const worker = new DecoderWorkerInstance();
self.onmessage = (event) => worker.handleMessage(event);

// utils/wasm-test.ts
// js/utils/wasm-test.ts
import { 
  WasmModule, 
  IMFDecoder, 
  ReferenceData, 
  FrameToken, 
  VerifyResult,
  TestResult,
  PlayerStatus,
  DecoderStatus 
} from '../types';

class TestUI {
  private decoder: IMFDecoder | null = null;
  private playerStatus: PlayerStatus = PlayerStatus.Idle;
  private decoderStatus: DecoderStatus = DecoderStatus.Idle;

  private buttons: {
      verify: HTMLButtonElement;
      init: HTMLButtonElement;
      start: HTMLButtonElement;
      process: HTMLButtonElement;
      pause: HTMLButtonElement;
      clear: HTMLButtonElement;
  };

  private statusElements: {
      player: HTMLElement;
      decoder: HTMLElement;
  };

  constructor() {
      this.initializeElements();
      this.setupEventListeners();
      this.interceptConsole();
  }

  private initializeElements() {
      this.buttons = {
          verify: document.getElementById('verifyWasm') as HTMLButtonElement,
          init: document.getElementById('initDecoder') as HTMLButtonElement,
          start: document.getElementById('startDecoder') as HTMLButtonElement,
          process: document.getElementById('processFrame') as HTMLButtonElement,
          pause: document.getElementById('pauseDecoder') as HTMLButtonElement,
          clear: document.getElementById('clearLog') as HTMLButtonElement
      };

      this.statusElements = {
          player: document.getElementById('player-status') as HTMLElement,
          decoder: document.getElementById('decoder-status') as HTMLElement
      };
  }

  private setupEventListeners() {
      this.buttons.verify.onclick = () => this.verifyWasm();
      this.buttons.init.onclick = () => this.initializeDecoder();
      this.buttons.start.onclick = () => this.startDecoder();
      this.buttons.process.onclick = () => this.processFrame();
      this.buttons.pause.onclick = () => this.pauseDecoder();
      this.buttons.clear.onclick = () => this.clearLog();
  }

  private updateStatus(type: 'player' | 'decoder', status: PlayerStatus | DecoderStatus) {
      const element = this.statusElements[type];
      const statusMap = type === 'player' ? PlayerStatus : DecoderStatus;
      const statusName = statusMap[status];
      
      // Remove all existing status classes
      element.className = 'status-value';
      
      // Add appropriate status class
      switch(status) {
          case 0: element.classList.add('status-idle'); break;
          case 1: element.classList.add('status-ready'); break;
          case 2: element.classList.add('status-playing'); break;
          case 3: element.classList.add('status-paused'); break;
          default: element.classList.add('status-error');
      }
      
      element.textContent = statusName;
  }

  private async verifyWasm() {
      try {
          this.buttons.verify.disabled = true;
          this.log('info', 'Verifying WASM...');
          
          const result = await verifyWasmBuild();
          if (result.success && result.decoder) {
              this.decoder = result.decoder;
              this.buttons.init.disabled = false;
              this.updateStatus('player', PlayerStatus.Ready);
              this.log('success', 'WASM verification successful!');
          } else {
              this.updateStatus('player', PlayerStatus.Idle);
              this.log('error', 'WASM verification failed!');
          }
      } catch (error) {
          this.log('error', `Error: ${error.message}`);
          this.updateStatus('player', PlayerStatus.Idle);
      } finally {
          this.buttons.verify.disabled = false;
      }
  }

  private async initializeDecoder() {
      try {
          this.buttons.init.disabled = true;
          this.updateStatus('decoder', DecoderStatus.Initializing);
          
          if (!this.decoder) {
              throw new Error('Decoder not initialized');
          }

          // Create and set reference data
          const reference_data = this.createReferenceData();
          await this.decoder.set_reference_data(reference_data);
          
          this.buttons.start.disabled = false;
          this.updateStatus('decoder', DecoderStatus.Ready);
          this.log('success', 'Decoder initialized successfully');
      } catch (error) {
          this.log('error', `Initialization error: ${error.message}`);
          this.updateStatus('decoder', DecoderStatus.Idle);
      }
  }

  private async startDecoder() {
      try {
          this.buttons.start.disabled = true;
          this.updateStatus('decoder', DecoderStatus.Open);
          
          // Enable frame processing and pause
          this.buttons.process.disabled = false;
          this.buttons.pause.disabled = false;
          
          this.log('success', 'Decoder started');
      } catch (error) {
          this.log('error', `Start error: ${error.message}`);
          this.updateStatus('decoder', DecoderStatus.Ready);
      }
  }

  private async processFrame() {
      if (!this.decoder) return;

      try {
          // Create test frame data
          const frame = new Float32Array(32).fill(0.5);
          const token: FrameToken = {
              token: frame,
              frame_index: 0
          };

          await this.decoder.process_tokens([token]);
          const batchResult = await this.decoder.process_batch();
          
          this.log('success', `Frame processed: ${batchResult}`);
      } catch (error) {
          this.log('error', `Process error: ${error.message}`);
      }
  }

  private async pauseDecoder() {
      try {
          this.updateStatus('decoder', DecoderStatus.Pause);
          this.buttons.process.disabled = true;
          this.buttons.pause.disabled = true;
          this.buttons.start.disabled = false;
          
          this.log('info', 'Decoder paused');
      } catch (error) {
          this.log('error', `Pause error: ${error.message}`);
      }
  }

  private createReferenceData(): ReferenceData {
      return {
          features: [
              {
                  tensor: new Float32Array(1 * 128 * 64 * 64).fill(0.5),
                  shape: [1, 128, 64, 64]
              },
              {
                  tensor: new Float32Array(1 * 256 * 32 * 32).fill(0.5),
                  shape: [1, 256, 32, 32]
              },
              {
                  tensor: new Float32Array(1 * 512 * 16 * 16).fill(0.5),
                  shape: [1, 512, 16, 16]
              },
              {
                  tensor: new Float32Array(1 * 512 * 8 * 8).fill(0.5),
                  shape: [1, 512, 8, 8]
              }
          ],
          token: new Float32Array(32).fill(0.1)
      };
  }

  private log(type: 'info' | 'error' | 'success', ...args: any[]) {
      const logDiv = document.getElementById('log')!;
      const line = document.createElement('div');
      line.className = type;
      line.textContent = args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
      ).join(' ');
      logDiv.appendChild(line);
      logDiv.scrollTop = logDiv.scrollHeight;
  }

  private clearLog() {
      const logDiv = document.getElementById('log')!;
      logDiv.innerHTML = '';
  }
}

// Initialize when document is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => new TestUI());
} else {
  new TestUI();
}

export { TestUI };

// index.ts
// js/index.ts
import { init, verifyWasmBuild, runDecoderTests } from './utils/wasm-test';

class TestUI {
    private verifyButton: HTMLButtonElement;
    private testButton: HTMLButtonElement;
    private clearButton: HTMLButtonElement;
    private statusDiv: HTMLDivElement;
    private logDiv: HTMLDivElement;
    private decoder: any = null;

    constructor() {
        this.verifyButton = document.getElementById('verifyWasm') as HTMLButtonElement;
        this.testButton = document.getElementById('runTests') as HTMLButtonElement;
        this.clearButton = document.getElementById('clearLog') as HTMLButtonElement;
        this.statusDiv = document.getElementById('status') as HTMLDivElement;
        this.logDiv = document.getElementById('log') as HTMLDivElement;

        this.setupEventListeners();
        this.interceptConsole();
    }

    private setupEventListeners() {
        this.verifyButton.addEventListener('click', () => this.verifyWasm());
        this.testButton.addEventListener('click', () => this.runTests());
        this.clearButton.addEventListener('click', () => this.clearLog());
    }

    private interceptConsole() {
        const originalLog = console.log;
        const originalError = console.error;

        console.log = (...args) => {
            this.log('log', ...args);
            originalLog.apply(console, args);
        };

        console.error = (...args) => {
            this.log('error', ...args);
            originalError.apply(console, args);
        };
    }

    private log(type: 'log' | 'error', ...args: any[]) {
        const line = document.createElement('div');
        line.className = type === 'error' ? 'error' : '';
        line.textContent = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' ');
        this.logDiv.appendChild(line);
        this.logDiv.scrollTop = this.logDiv.scrollHeight;
    }

    private async verifyWasm() {
        try {
            this.verifyButton.disabled = true;
            this.setStatus('Verifying WASM...', 'info');
            
            const result = await verifyWasmBuild();
            if (result.success && result.decoder) {
                this.decoder = result.decoder;
                this.testButton.disabled = false;
                this.setStatus('WASM verification successful!', 'success');
            } else {
                this.setStatus('WASM verification failed!', 'error');
            }
        } catch (error) {
            this.setStatus(`Error: ${error.message}`, 'error');
        } finally {
            this.verifyButton.disabled = false;
        }
    }

    private async runTests() {
        if (!this.decoder) {
            this.setStatus('Please verify WASM first', 'error');
            return;
        }

        try {
            this.testButton.disabled = true;
            this.setStatus('Running tests...', 'info');
            
            const result = await runDecoderTests(this.decoder);
            if (result.success) {
                this.setStatus(result.message || 'Tests completed successfully', 'success');
            } else {
                this.setStatus(`Tests failed: ${result.error}`, 'error');
            }
        } catch (error) {
            this.setStatus(`Error: ${error.message}`, 'error');
        } finally {
            this.testButton.disabled = false;
        }
    }

    private setStatus(message: string, type: 'success' | 'error' | 'info') {
        this.statusDiv.textContent = message;
        this.statusDiv.className = `status ${type}`;
    }

    private clearLog() {
        this.logDiv.innerHTML = '';
    }
}

// Initialize when the document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new TestUI());
} else {
    new TestUI();
}


