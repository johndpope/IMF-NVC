import * as tf from '@tensorflow/tfjs';
import { 
    PlayerStatus, 
    MessageType, 
    DecoderConfig,
    WorkerMessage, 
    ReferenceData,
    FrameStats,
    ModelInputConfig,
    FrameData
} from '../types';

export class IMFPlayer {
    private worker: Worker;
    private status: PlayerStatus = PlayerStatus.Idle;
    private model: tf.GraphModel | null = null;
    private callbacks: Map<MessageType, Function>;
    private config: DecoderConfig;
    private frameBuffer: FrameData[] = [];
    private frameIndex: number = 0;
    private readonly bufferSize: number = 30;
    private modelConfig: ModelInputConfig;
    private lastProcessedFrame: tf.Tensor | null = null;
    private frameCallback: ((stats: FrameStats) => void) | null = null;
    private errorCallback: ((error: Error) => void) | null = null;
    private lastFrameTime: number = 0;

    constructor(config: DecoderConfig) {
        this.config = config;
        this.callbacks = new Map();
        this.worker = new Worker(new URL('./decoder.worker.ts', import.meta.url));
        this.modelConfig = {
            inputShape: [1, config.height, config.width, 3],
            inputNormalization: {
                mean: [0.485, 0.456, 0.406],
                std: [0.229, 0.224, 0.225]
            },
            maxBatchSize: 1
        };
        this.setupWorkerListeners();
        this.initialize();
    }

    private setupWorkerListeners() {
        this.worker.onmessage = (event: MessageEvent<WorkerMessage>) => {
            const { type, data, error } = event.data;
            
            const callback = this.callbacks.get(type);
            if (callback) {
                callback(data);
                this.callbacks.delete(type);
            }

            if (error) {
                this.handleDecoderError(error);
                return;
            }

            switch (type) {
                case MessageType.DecoderCreated:
                    this.status = PlayerStatus.Ready;
                    break;
                case MessageType.FrameProcessed:
                    this.handleFrameProcessed(data);
                    break;
                case MessageType.DecoderRecovered:
                    this.handleDecoderRecovery(data);
                    break;
            }
        };

        this.worker.onerror = (error) => {
            this.handleDecoderError(error);
        };
    }

    async initialize(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.callbacks.set(MessageType.DecoderInited, resolve);
            this.worker.postMessage({ 
                type: MessageType.DecoderInit,
                data: this.config
            });
        });
    }

    async loadModel(modelUrl: string): Promise<boolean> {
        try {
            this.model = await tf.loadGraphModel(modelUrl);
            const referenceData = this.createReferenceData();
            
            return new Promise((resolve) => {
                this.callbacks.set(MessageType.ReferenceDataSet, (status: boolean) => {
                    resolve(status);
                });

                this.worker.postMessage({
                    type: MessageType.DecoderInit,
                    data: referenceData
                });
            });
        } catch (error) {
            console.error('Failed to load model:', error);
            return false;
        }
    }

    private createReferenceData(): ReferenceData {
        const features = [
            tf.zeros([1, 128, 64, 64]),
            tf.zeros([1, 256, 32, 32]),
            tf.zeros([1, 512, 16, 16]),
            tf.zeros([1, 512, 8, 8])
        ];

        const token = tf.zeros([1, 32]);

        return {
            features: features.map(tensor => ({
                tensor: tensor.dataSync() as Float32Array,
                shape: tensor.shape
            })),
            token: token.dataSync() as Float32Array
        };
    }

    private async getNextFrameData(): Promise<FrameData> {
        try {
            if (this.lastProcessedFrame) {
                this.lastProcessedFrame.dispose();
                this.lastProcessedFrame = null;
            }

            const inputTensor = await this.prepareInputTensor();
            const startTime = performance.now();
            const outputTensor = await this.model!.executeAsync(inputTensor) as tf.Tensor;
            const inferenceTime = performance.now() - startTime;
            const processedData = await this.processModelOutput(outputTensor);
            
            inputTensor.dispose();
            outputTensor.dispose();

            this.frameIndex = (this.frameIndex + 1) % this.bufferSize;

            return {
                frameIndex: this.frameIndex,
                timestamp: Date.now(),
                data: processedData,
                metadata: {
                    inferenceTime,
                    inputShape: this.modelConfig.inputShape,
                    outputShape: processedData.shape
                }
            };
        } catch (error) {
            console.error('Error getting next frame:', error);
            throw new Error(`Frame processing failed: ${error}`);
        }
    }

    private async processFrame(): Promise<void> {
        if (!this.model || this.status !== PlayerStatus.Playing) return;

        try {
            const frameData = await this.getNextFrameData();
            this.worker.postMessage({
                type: MessageType.ProcessFrame,
                data: [{
                    token: Array.from(frameData.data.values),
                    frame_index: frameData.frameIndex
                }]
            });
        } catch (error) {
            this.handleDecoderError(error);
        }
    }

    private handleFrameProcessed(data: any) {
        if (this.frameCallback) {
            this.frameCallback(data.frameStats);
        }

        if (this.status === PlayerStatus.Playing) {
            this.requestNextFrame();
        }
    }

    private handleDecoderError(error: any) {
        console.error('Decoder error:', error);
        if (this.errorCallback) {
            this.errorCallback(new Error(String(error)));
        }
    }

    private handleDecoderRecovery(data: any) {
        console.log('Decoder recovered:', data);
        if (data.success && this.status === PlayerStatus.Playing) {
            this.requestNextFrame();
        }
    }

    private requestNextFrame() {
        const now = performance.now();
        const timeSinceLastFrame = now - this.lastFrameTime;

        if (timeSinceLastFrame >= 16.67) { // Target 60fps
            this.processFrame();
            this.lastFrameTime = now;
        } else {
            setTimeout(() => this.requestNextFrame(), 16.67 - timeSinceLastFrame);
        }
    }

    public setModelConfig(config: Partial<ModelInputConfig>) {
        this.modelConfig = {
            ...this.modelConfig,
            ...config
        };
    }

    public getBufferStatus(): {current: number, total: number} {
        return {
            current: this.frameBuffer.length,
            total: this.bufferSize
        };
    }

    public onFrameProcessed(callback: (stats: FrameStats) => void) {
        this.frameCallback = callback;
    }

    public onError(callback: (error: Error) => void) {
        this.errorCallback = callback;
    }

    public async start() {
        if (this.status !== PlayerStatus.Ready) {
            throw new Error('Decoder not ready');
        }
        await this.preloadFrames();
        this.status = PlayerStatus.Playing;
        this.requestNextFrame();
    }

    public stop() {
        this.status = PlayerStatus.Ready;
    }

    public async destroy() {
        this.stop();
        await this.cleanupResources();
        if (this.model) {
            this.model.dispose();
        }
        this.worker.terminate();
        this.status = PlayerStatus.Destroyed;
    }

    // Additional helper methods
    private async prepareInputTensor(): Promise<tf.Tensor> {
        return tf.tidy(() => {
            let inputTensor = tf.randomNormal(this.modelConfig.inputShape);
            if (this.modelConfig.inputNormalization) {
                const { mean, std } = this.modelConfig.inputNormalization;
                inputTensor = tf.sub(inputTensor, mean);
                inputTensor = tf.div(inputTensor, std);
            }
            if (inputTensor.shape[0] !== 1) {
                inputTensor = tf.expandDims(inputTensor, 0);
            }
            this.lastProcessedFrame = inputTensor;
            return inputTensor;
        });
    }

    private async processModelOutput(outputTensor: tf.Tensor): Promise<tf.TensorBuffer<tf.Rank>> {
        const outputData = await outputTensor.buffer();
        await this.applyPostProcessing(outputData);
        return outputData;
    }

    private async applyPostProcessing(data: tf.TensorBuffer<tf.Rank>): Promise<void> {
        tf.tidy(() => {
            if (this.modelConfig.outputDenormalization) {
                const { scale, offset } = this.modelConfig.outputDenormalization;
                for (let i = 0; i < data.size; i++) {
                    const value = data.values[i];
                    data.values[i] = value * scale + offset;
                }
            }
            for (let i = 0; i < data.size; i++) {
                data.values[i] = Math.max(0, Math.min(1, data.values[i]));
            }
        });
    }

    private async cleanupResources(): Promise<void> {
        await this.clearBuffer();
        if (this.lastProcessedFrame) {
            this.lastProcessedFrame.dispose();
            this.lastProcessedFrame = null;
        }
        tf.engine().startScope();
        tf.engine().endScope();
    }

    public async preloadFrames(count: number = this.bufferSize): Promise<void> {
        for (let i = 0; i < count; i++) {
            try {
                const frameData = await this.getNextFrameData();
                this.frameBuffer.push(frameData);
            } catch (error) {
                console.error(`Failed to preload frame ${i}:`, error);
                break;
            }
        }
    }

    public async clearBuffer(): Promise<void> {
        this.frameBuffer.forEach(frame => {
            if (frame.data instanceof tf.Tensor) {
                frame.data.dispose();
            }
        });
        this.frameBuffer = [];
        this.frameIndex = 0;
    }
}
import * as tf from '@tensorflow/tfjs';
import { PlayerStatus, MessageType, ReferenceData } from '../types';

export class IMFPlayer {
    private worker: Worker;
    private status: PlayerStatus = PlayerStatus.Idle;
    private model: tf.GraphModel | null = null;
    private callbacks: Map<string, Function> = new Map();

    constructor(width: number, height: number) {
        this.worker = new Worker(new URL('./decoder.worker', import.meta.url));
        this.setupWorkerListeners();
    }

    private setupWorkerListeners() {
        this.worker.onmessage = (event) => {
            const { type, data, error } = event.data;
            
            const callback = this.callbacks.get(type);
            if (callback) {
                callback(data);
                this.callbacks.delete(type);
            }

            switch (type as MessageType) {
                case MessageType.DecoderCreated:
                    this.status = PlayerStatus.Ready;
                    break;
                case MessageType.Error:
                    console.error('Decoder error:', error);
                    break;
            }
        };
    }

    async initialize(): Promise<void> {
        return new Promise((resolve, reject) => {
            this.callbacks.set(MessageType.DecoderInited, resolve);
            this.worker.postMessage({ type: MessageType.DecoderInit });
        });
    }

    async loadModel(modelUrl: string): Promise<boolean> {
        try {
            this.model = await tf.loadGraphModel(modelUrl);
            const referenceData = this.createReferenceData();
            
            return new Promise((resolve, reject) => {
                this.callbacks.set(MessageType.ReferenceDataSet, (status: boolean) => {
                    resolve(status);
                });

                this.worker.postMessage({
                    type: MessageType.DecoderInit,
                    data: referenceData
                });
            });
        } catch (error) {
            console.error('Failed to load model:', error);
            return false;
        }
    }

    private createReferenceData(): ReferenceData {
        const features = [
            tf.zeros([1, 128, 64, 64]),
            tf.zeros([1, 256, 32, 32]),
            tf.zeros([1, 512, 16, 16]),
            tf.zeros([1, 512, 8, 8])
        ];
        const token = tf.zeros([1, 32]);

        return {
            features: features.map(tensor => ({
                tensor: tensor.dataSync() as Float32Array,
                shape: tensor.shape
            })),
            token: token.dataSync() as Float32Array
        };
    }

    async processFrame(inputData: Float32Array, inputShape: number[]): Promise<void> {
        if (!this.model) return;

        try {
            const inputTensor = tf.tensor(inputData, inputShape);
            const outputTensor = await this.model.executeAsync(inputTensor);
            const outputData = await (outputTensor as tf.Tensor).data();

            return new Promise((resolve) => {
                this.callbacks.set(MessageType.TokensProcessed, resolve);
                
                this.worker.postMessage({
                    type: MessageType.TokensProcessed,
                    data: [{
                        token: Array.from(outputData),
                        frame_index: 0
                    }]
                });
            });
        } catch (error) {
            console.error('Error processing frame:', error);
        }
    }

    destroy() {
        if (this.model) {
            this.model.dispose();
        }
        this.worker.terminate();
        this.status = PlayerStatus.Destroyed;
    }
}

// js/decoder/worker.ts
import init, { IMFDecoder } from '../../pkg/imf_decoder';
import { MessageType, DecoderStatus } from '../types';

class DecoderWorkerInstance {
    private decoder: IMFDecoder | null = null;
    private status: DecoderStatus = DecoderStatus.Idle;

    async initialize() {
        try {
            await init();
            this.decoder = new IMFDecoder(1920, 1080);
            this.status = DecoderStatus.Ready;
            self.postMessage({ type: MessageType.DecoderCreated });
        } catch (error) {
            self.postMessage({ 
                type: MessageType.Error, 
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }

    handleMessage(event: MessageEvent) {
        const { type, data } = event.data;

        try {
            switch (type as MessageType) {
                case MessageType.DecoderInit:
                    this.initialize();
                    break;
                case MessageType.TokensProcessed:
                    this.processTokens(data);
                    break;
            }
        } catch (error) {
            self.postMessage({ 
                type: MessageType.Error, 
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }

    async processTokens(tokens: any) {
        if (!this.decoder || this.status !== DecoderStatus.Ready) {
            throw new Error('Decoder not ready');
        }

        const result = await this.decoder.process_tokens(tokens);
        self.postMessage({ type: MessageType.TokensProcessed, result });

        const batchResult = await this.decoder.process_batch();
        self.postMessage({ type: MessageType.BatchProcessed, result: batchResult });
    }
}

const worker = new DecoderWorkerInstance();
self.onmessage = (event) => worker.handleMessage(event);
declare module '@pkg/imf_decoder' {
    export interface ReferenceFeature {
        tensor: Float32Array;
        shape: number[];
    }

    export interface ReferenceData {
        features: ReferenceFeature[];
        token: Float32Array;
    }

    export interface FrameToken {
        token: Float32Array | number[];
        frame_index: number;
    }

    export interface DecoderStatus {
        initialized: boolean;
        running: boolean;
        metrics: {
            frameCount: number;
            lastFrameTime: number;
        };
        queue: {
            inputQueueSize: number;
            processingQueueSize: number;
            outputQueueSize: number;
        };
    }

    export interface DecoderCapabilities {
        version: string;
        dimensions: string;
        features: string[];
        methods: string[];
    }

    export class IMFDecoder {
        constructor(width: number, height: number);
        free(): void;
        initialize_render_context(canvas: HTMLCanvasElement): Promise<string>;
        get_capabilities(): DecoderCapabilities;
        test(): string;
        get_status(): DecoderStatus;
        start_player_loop(): Promise<void>;
        stop_player_loop(): void;
        
        // Debug mode methods
        debug_mode: boolean;
        enable_debug_mode(): void;
        disable_debug_mode(): void;
        is_debug_mode(): boolean;
        
        // Diagnostic mode property
        diagnostic_mode: boolean;
        
        // Other methods
        set_reference_data(data: ReferenceData): Promise<string>;
        process_tokens(tokens: FrameToken[]): Promise<string>;
        process_batch(): Promise<string>;
        get_reference_status(): string;
    }

    export function initSync(): void;
    export function start(): void;
    export default function init(): Promise<void>;
}
// js/types/index.ts
import * as tf from '@tensorflow/tfjs';
import { IMFDecoder, ReferenceData as WasmReferenceData, FrameToken as WasmFrameToken } from '@pkg/imf_decoder';

// Enums
export enum PlayerStatus {
  Idle = 0,
  Ready = 1,
  Playing = 2,
  Pause = 3,
  Destroyed = 4
}

export enum DecoderStatus {
  Idle = 0,
  Initializing = 1,
  Ready = 2,
  Open = 3,
  Pause = 4,
  Closed = 5
}



// Configuration Interfaces
export interface DecoderConfig {
  width: number;
  height: number;
  maxQueueSize?: number;
  batchSize?: number;
  enablePerfMonitoring?: boolean;
}

// Data Structure Interfaces 
export interface ReferenceFeature {
  tensor: Float32Array;
  shape: number[];
}

export interface ReferenceData {
  features: ReferenceFeature[];
  token: Float32Array;
}

export interface FrameToken {
  token: Float32Array;
  frame_index: number;
}

// WASM Related Interfaces
export interface WasmModule {
  IMFDecoder: new (width: number, height: number) => IMFDecoder;
  default: () => Promise<void>;
  [key: string]: any;
}



// Result Interfaces
export interface VerifyResult {
  success: boolean;
  module?: WasmModule;
  decoder?: IMFDecoder;
  error?: Error;
}

export interface TestResult {
  success: boolean;
  message?: string;
  error?: string;
}

// Worker Message Interface
export interface WorkerMessage {
  type: MessageType;
  data?: any;
  error?: string;
}


export enum MessageType {
  DecoderInit = 'DecoderInit',
  DecoderInited = 'DecoderInited',
  ProcessFrame = 'ProcessFrame',
  FrameProcessed = 'FrameProcessed',
  UpdateRenderPass = 'UpdateRenderPass',
  DecoderError = 'DecoderError',
  DecoderRecovered = 'DecoderRecovered',
  DecoderMetrics = 'DecoderMetrics',
  DecoderCreated = 'DecoderCreated',
  WasmLoaded = 'WasmLoaded',
  DecoderReady = 'DecoderReady',
  ReferenceDataSet = 'ReferenceDataSet',
  TokensProcessed = 'TokensProcessed',
  BatchProcessed = 'BatchProcessed',
  Error = 'Error'
}

export interface WorkerMessage {
  type: MessageType;
  data?: any;
  error?: string;
}

export interface FrameStats {
  frameTime: number;        // Time to process frame
  gpuTime: number;         // GPU processing time
  frameCount: number;      // Total frames processed
  droppedFrames: number;   // Frames exceeding timing budget
  lastFrameTimestamp: number;
}

export interface RenderPassConfig {
  name: string;
  format: GPUTextureFormat;
  descriptors: {
      colorAttachments: Array<{
          clearValue: GPUColor;
          loadOp: GPULoadOp;
          storeOp: GPUStoreOp;
      }>;
  };
}

export interface TextureDescriptor {
  id: number;
  width: number;
  height: number;
  format: GPUTextureFormat;
  usage: GPUTextureUsageFlags;
}

export interface ModelInputConfig {
  inputShape: number[];
  inputNormalization?: {
      mean: number[];
      std: number[];
  };
  outputDenormalization?: {
      scale: number;
      offset: number;
  };
  maxBatchSize: number;
}

export interface FrameData {
  frameIndex: number;
  timestamp: number;
  data: tf.TensorBuffer<tf.Rank>;
  metadata: {
      inferenceTime: number;
      inputShape: number[];
      outputShape: number[];
  };
}

declare module '*.wasm' {
  const content: WebAssembly.Module;
  export default content;
}


import init   from '@pkg/imf_decoder';
import {IMFDecoder}   from '@pkg/imf_decoder';
import type { VerifyResult, TestResult } from '../types';

async function verifyWasmBuild(): Promise<VerifyResult> {
    console.log('🔍 Starting WASM verification...');
    
    try {
        await init();
        const exports = Object.keys(await import('@pkg/imf_decoder'));
        console.log('📦 WASM Exports:', exports);

        const width = 640;
        const height = 480;
        console.log(`Creating new IMF decoder with dimensions ${width}x${height}`);
        
        const decoder = new IMFDecoder(width, height);
        const methods = Object.getOwnPropertyNames(IMFDecoder.prototype);
        console.log('🔧 IMFDecoder Methods:', methods);

        const testResult = decoder.test();
        console.log('🧪 Test method output:', testResult);
        console.log('IMFDecoder instance:', decoder);

        if (!testResult.includes('IMFDecoder working!')) {
            throw new Error('Decoder test failed');
        }

        console.log('✅ WASM verification successful!');
        return {
            success: true,
            decoder
        };
    } catch (error) {
        console.error('❌ WASM verification failed:', error);
        return {
            success: false,
            error: error instanceof Error ? error : new Error('Unknown error')
        };
    }
}

 async function runDecoderTests(decoder: IMFDecoder): Promise<TestResult> {
  try {
      console.log('Available methods:', Object.getOwnPropertyNames(IMFDecoder.prototype));
      
      // Test 1: Basic functionality
      const initialTest = decoder.test();
      console.log('Initial test:', initialTest);

      // Test 2: Set diagnostic mode
      console.log('Setting diagnostic mode...');
      decoder.diagnostic_mode = true;
      console.log('Diagnostic mode set to:', decoder.diagnostic_mode);
      
      if (!decoder.diagnostic_mode) {
          throw new Error('Failed to set diagnostic mode');
      }
      console.log('Diagnostic mode is now:', decoder.diagnostic_mode);

      // Test 3: Set reference data
      console.log('Setting reference data...');
      const referenceData = {
          features: [
              {
                  tensor: new Float32Array(1 * 128 * 64 * 64).fill(0.5),
                  shape: [1, 128, 64, 64]
              },
              {
                  tensor: new Float32Array(1 * 256 * 32 * 32).fill(0.5),
                  shape: [1, 256, 32, 32]
              },
              {
                  tensor: new Float32Array(1 * 512 * 16 * 16).fill(0.5),
                  shape: [1, 512, 16, 16]
              },
              {
                  tensor: new Float32Array(1 * 512 * 8 * 8).fill(0.5),
                  shape: [1, 512, 8, 8]
              }
          ],
          token: new Float32Array(32).fill(0.1)
      };

      const refResult = await decoder.set_reference_data(referenceData);
      console.log('Set reference data result:', refResult);

      // Test 4: Process test frame
      console.log('Processing tokens...');
      const frameWidth = 640;
      const frameHeight = 480;
      const channelCount = 4; // RGBA
      const frameData = new Float32Array(frameWidth * frameHeight * channelCount).fill(0.5);

      if (typeof decoder.process_tokens !== 'function') {
          throw new Error('process_tokens method not found on decoder');
      }
      console.log('process_tokens exists:', typeof decoder.process_tokens);

      const tokenResult = await decoder.process_tokens([{
          token: frameData,
          frame_index: 0
      }]);

      // Test 5: Process batch
      const batchResult = await decoder.process_batch();

      return {
          success: true,
          message: 'All decoder tests completed successfully'
      };

  } catch (error) {
      console.error('Error processing tokens:', error);
      console.error('Stack:', error);
      console.error('Test sequence failed:', error);
      return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
      };
  }
}

async function initializeDecoder(): Promise<void> {
  try {
      console.log('🔍 Starting WASM verification...');
      const { success, module: wasm_module, decoder, error } = await verifyWasmBuild();
      
      if (!success || !decoder) {
          console.error('Failed to initialize decoder:', error);
          if (error?.stack) console.error('Stack:', error.stack);
          return;
      }

      console.log('IMFDecoder instance:', decoder);
      console.log('✅ WASM verification successful!');
      
      // Store for later use
      (window as any).decoder = decoder;
      (window as any).wasm = wasm_module;
      
      // Run decoder tests
      await runDecoderTests(decoder);
      
      console.log('IMFDecoder initialized successfully');
  } catch (e) {
      console.error('Failed to initialize decoder:', e);
      if (e instanceof Error) console.error('Stack:', e.stack);
      
      try {
          // Additional debugging info
          const wasm_module = await import('@pkg/imf_decoder');
      
          // Wait for module initialization
          await init();
          
          // Log all available exports
          console.log('📦 WASM Exports:', Object.keys(wasm_module));
      } catch (importError) {
          console.error('Failed to import WASM module:', importError);
      }
  }
}



async function testAnimationFrame(decoder: IMFDecoder): Promise<TestResult> {
    console.log('🎬 Starting animation frame test...');
    
    try {
        // Track frame count and timing
        let frameCount = 0;
        let startTime = performance.now();
        let lastFrameTime = startTime;
        const testDuration = 3000; // Run test for 3 seconds
        const targetFPS = 60;
        const frameTimings: number[] = [];

        // Create test data
        const referenceData = {
            features: [
                {
                    tensor: new Float32Array(1 * 128 * 64 * 64).fill(0.5),
                    shape: [1, 128, 64, 64]
                },
                {
                    tensor: new Float32Array(1 * 256 * 32 * 32).fill(0.5),
                    shape: [1, 256, 32, 32]
                },
                {
                    tensor: new Float32Array(1 * 512 * 16 * 16).fill(0.5),
                    shape: [1, 512, 16, 16]
                },
                {
                    tensor: new Float32Array(1 * 512 * 8 * 8).fill(0.5),
                    shape: [1, 512, 8, 8]
                }
            ],
            token: new Float32Array(32).fill(0.1)
        };

        // Set up decoder
        console.log('Setting reference data...');
        await decoder.set_reference_data(referenceData);
        decoder.diagnostic_mode = true;

        // Create a promise that resolves when the animation test is complete
        const animationTest = new Promise<void>((resolve) => {
            function animationFrame(timestamp: number) {
                const currentTime = performance.now();
                const elapsed = currentTime - startTime;
                const frameDuration = currentTime - lastFrameTime;
                
                // Process frame
                const frameData = new Float32Array(640 * 480 * 4).fill(0.5);
                decoder.process_tokens([{
                    token: Array.from(frameData),
                    frame_index: frameCount
                }]);
                
                // Track metrics
                frameCount++;
                frameTimings.push(frameDuration);
                lastFrameTime = currentTime;

                // Continue animation if test duration hasn't elapsed
                if (elapsed < testDuration) {
                    requestAnimationFrame(animationFrame);
                } else {
                    resolve();
                }
            }

            // Start animation loop
            requestAnimationFrame(animationFrame);
        });

        // Wait for animation test to complete
        await animationTest;

        // Calculate test results
        const averageFrameTime = frameTimings.reduce((a, b) => a + b, 0) / frameTimings.length;
        const measuredFPS = 1000 / averageFrameTime;
        const minFrameTime = Math.min(...frameTimings);
        const maxFrameTime = Math.max(...frameTimings);
        const frameTimeJitter = maxFrameTime - minFrameTime;

        // Log results
        console.log('🎥 Animation test completed:');
        console.log(`Frames processed: ${frameCount}`);
        console.log(`Average frame time: ${averageFrameTime.toFixed(2)}ms`);
        console.log(`Measured FPS: ${measuredFPS.toFixed(2)}`);
        console.log(`Frame time range: ${minFrameTime.toFixed(2)}ms - ${maxFrameTime.toFixed(2)}ms`);
        console.log(`Frame time jitter: ${frameTimeJitter.toFixed(2)}ms`);

        // Verify test results
        const performanceThreshold = 0.8; // 80% of target performance
        const targetFrameTime = 1000 / targetFPS;
        const isPerformant = averageFrameTime <= targetFrameTime / performanceThreshold;
        const isStable = frameTimeJitter < targetFrameTime;

        if (!isPerformant || !isStable) {
            throw new Error(
                `Performance targets not met:\n` +
                `Average frame time: ${averageFrameTime.toFixed(2)}ms (target: ${targetFrameTime}ms)\n` +
                `Frame time jitter: ${frameTimeJitter.toFixed(2)}ms`
            );
        }

        return {
            success: true,
            message: `Animation test completed successfully:\n` +
                    `Processed ${frameCount} frames at ${measuredFPS.toFixed(1)} FPS\n` +
                    `Frame time: ${averageFrameTime.toFixed(1)}ms ±${(frameTimeJitter/2).toFixed(1)}ms`
        };

    } catch (error) {
        console.error('❌ Animation test failed:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}

// Update the main test function to include animation testing
async function runEnhancedDecoderTests(decoder: IMFDecoder): Promise<TestResult> {
    try {
        // Run existing decoder tests first
        const basicTests = await runDecoderTests(decoder);
        if (!basicTests.success) {
            throw new Error(`Basic decoder tests failed: ${basicTests.error}`);
        }

        // Run animation frame test
        console.log('Running animation frame test...');
        const animationTest = await testAnimationFrame(decoder);
        if (!animationTest.success) {
            throw new Error(`Animation test failed: ${animationTest.error}`);
        }

        return {
            success: true,
            message: `All tests completed successfully.\n${animationTest.message}`
        };

    } catch (error) {
        console.error('Test sequence failed:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}


// Initialize when page loads
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeDecoder);
} else {
  initializeDecoder();
}

export { initializeDecoder, verifyWasmBuild, runDecoderTests, runEnhancedDecoderTests, testAnimationFrame };
// js/utils/performance-monitor.ts
import * as tf from '@tensorflow/tfjs';

export class PerformanceMonitor {
    private metrics: {
        fps: number[];
        inferenceTime: number[];
        memoryUsage: number[];
        tensorCount: number[];
    } = {
        fps: [],
        inferenceTime: [],
        memoryUsage: [],
        tensorCount: []
    };

    private readonly maxSamples: number = 60; // 1 second at 60fps
    private lastFrameTime: number = 0;

    public recordMetrics(inferenceTime: number): void {
        const now = performance.now();
        
        // Calculate FPS
        if (this.lastFrameTime > 0) {
            const fps = 1000 / (now - this.lastFrameTime);
            this.pushMetric('fps', fps);
        }
        this.lastFrameTime = now;

        // Record inference time
        this.pushMetric('inferenceTime', inferenceTime);

        // Record memory usage
        this.recordMemoryUsage();
    }

    private recordMemoryUsage(): void {
        const memoryInfo = tf.memory();
        this.pushMetric('memoryUsage', memoryInfo.numBytes);
        this.pushMetric('tensorCount', memoryInfo.numTensors);
    }

    private pushMetric(key: keyof typeof this.metrics, value: number): void {
        this.metrics[key].push(value);
        if (this.metrics[key].length > this.maxSamples) {
            this.metrics[key].shift();
        }
    }

    public getAverageMetrics(): {[key: string]: number} {
        const result: {[key: string]: number} = {};
        
        for (const [key, values] of Object.entries(this.metrics)) {
            if (values.length > 0) {
                const sum = values.reduce((a, b) => a + b, 0);
                result[key] = sum / values.length;
            }
        }

        return result;
    }

    public getMetricsReport(): string {
        const averages = this.getAverageMetrics();
        return `
Performance Report:
------------------
FPS: ${averages.fps.toFixed(2)}
Inference Time: ${averages.inferenceTime.toFixed(2)}ms
Memory Usage: ${(averages.memoryUsage / 1024 / 1024).toFixed(2)}MB
Active Tensors: ${averages.tensorCount}
        `.trim();
    }

    public reset(): void {
        Object.keys(this.metrics).forEach(key => {
            this.metrics[key as keyof typeof this.metrics] = [];
        });
        this.lastFrameTime = 0;
    }
}
class LogInterceptor {
    private logElement: HTMLElement;
    private maxLogEntries: number = 1000;

    constructor() {
        this.logElement = document.getElementById('log') || document.createElement('div');
        this.setupConsoleInterceptor();
    }

    private setupConsoleInterceptor() {
        const originalConsole = {
            log: console.log,
            info: console.info,
            warn: console.warn,
            error: console.error,
            debug: console.debug
        };

        // Intercept console methods
        console.log = (...args: any[]) => {
            this.addLogEntry('log', ...args);
            originalConsole.log.apply(console, args);
        };

        console.info = (...args: any[]) => {
            this.addLogEntry('info', ...args);
            originalConsole.info.apply(console, args);
        };

        console.warn = (...args: any[]) => {
            this.addLogEntry('warn', ...args);
            originalConsole.warn.apply(console, args);
        };

        console.error = (...args: any[]) => {
            this.addLogEntry('error', ...args);
            originalConsole.error.apply(console, args);
        };

        console.debug = (...args: any[]) => {
            this.addLogEntry('debug', ...args);
            originalConsole.debug.apply(console, args);
        };
    }

    private formatMessage(args: any[]): string {
        return args.map(arg => {
            if (typeof arg === 'string') {
                return this.formatString(arg);
            }
            if (arg instanceof Error) {
                return `${arg.name}: ${arg.message}\n${arg.stack}`;
            }
            return typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg);
        }).join(' ');
    }

    private formatString(str: string): string {
        // Handle special formatting
        return str
            .replace(/\%c/g, '') // Remove CSS formatting placeholders
            .replace(/src\/wasm\/bindings\.rs:(\d+)/g, '<span class="log-file">src/wasm/bindings.rs:$1</span>')
            .replace(/(DEBUG|INFO|WARN|ERROR)/g, '<span class="log-level log-$1">$1</span>')
            .replace(/Token data length: (\d+)/g, '<span class="log-token">Token data length: $1</span>')
            .replace(/Frame data length: (\d+)/g, '<span class="log-frame">Frame data length: $1</span>')
            .replace(/WASM (Exports|verification)/g, '<span class="log-wasm">WASM $1</span>');
    }

    private addLogEntry(level: string, ...args: any[]) {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${level}`;

        // Add timestamp
        const timestamp = document.createElement('span');
        timestamp.className = 'log-timestamp';
        timestamp.textContent = new Date().toISOString().split('T')[1].split('.')[0];
        entry.appendChild(timestamp);

        // Add level indicator
        const levelIndicator = document.createElement('span');
        levelIndicator.className = `log-level log-${level}`;
        levelIndicator.textContent = level.toUpperCase();
        entry.appendChild(levelIndicator);

        // Add message
        const message = document.createElement('span');
        message.className = 'log-message';
        message.innerHTML = this.formatMessage(args);
        entry.appendChild(message);

        // Add to log and scroll
        this.logElement.appendChild(entry);
        this.trimOldEntries();
        this.logElement.scrollTop = this.logElement.scrollHeight;
    }

    private trimOldEntries() {
        while (this.logElement.children.length > this.maxLogEntries) {
            this.logElement.removeChild(this.logElement.firstChild!);
        }
    }

    clear() {
        this.logElement.innerHTML = '';
    }
}

// Initialize the log interceptor
const logInterceptor = new LogInterceptor();

// Export for use in other modules
export { logInterceptor,LogInterceptor };
import { init, verifyWasmBuild, runDecoderTests } from './utils/wasm-test';
import { 
    WasmModule,  
    ReferenceData, 
    FrameToken, 
    VerifyResult,
    TestResult,
    PlayerStatus,
    DecoderStatus 
} from './types';
import { logInterceptor, LogInterceptor } from './log-interceptor';
import '../styles/styles.css';

class TestUI {
    private decoder: IMFDecoder | null = null;
    private playerStatus: PlayerStatus = PlayerStatus.Idle;
    private decoderStatus: DecoderStatus = DecoderStatus.Idle;
    private animationFrameId: number | null = null;
    private frameCount: number = 0;
    private canvas: HTMLCanvasElement | null = null;
    private logInterceptor: LogInterceptor;
    private debugMetricsInterval: number | null = null;

    private buttons!: {
        verify: HTMLButtonElement;
        init: HTMLButtonElement;
        start: HTMLButtonElement;
        process: HTMLButtonElement;
        pause: HTMLButtonElement;
        clear: HTMLButtonElement;
        enableDebug: HTMLButtonElement;
        disableDebug: HTMLButtonElement;
    };

    private statusElements!: {
        player: HTMLElement;
        decoder: HTMLElement;
        debugMode: HTMLElement;
        frameCount: HTMLElement;
        frameTime: HTMLElement;
        queueSize: HTMLElement;
    };

    constructor() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initialize());
        } else {
            this.initialize();
        }
    }

    private initialize() {
        // Add setup debug panel before initializing elements
        this.setupDebugPanel();
        this.initializeElements();
        this.setupEventListeners();
        this.setupCanvas();
        this.logInterceptor = logInterceptor;
    }
    

    private setupCanvas() {
        this.canvas = document.getElementById('decoder-canvas') as HTMLCanvasElement;
        if (this.canvas) {
            this.canvas.width = 640;
            this.canvas.height = 480;
        }
    }


    private setupDebugPanel() {
        // Create debug panel container
        const debugPanel = document.createElement('div');
        debugPanel.className = 'debug-panel';
        debugPanel.innerHTML = `
            <div class="debug-header">Debug Controls</div>
            <div class="debug-content">
                <div class="debug-section">
                    <div class="debug-row">
                        <span>Debug Mode:</span>
                        <span id="debug-mode-status">Disabled</span>
                    </div>
                    <div class="debug-controls">
                        <button id="enableDebug">Enable Debug</button>
                        <button id="disableDebug">Disable Debug</button>
                    </div>
                </div>
                <div class="debug-section">
                    <div class="debug-row">
                        <span>Frame Count:</span>
                        <span id="frame-count">0</span>
                    </div>
                    <div class="debug-row">
                        <span>Frame Time:</span>
                        <span id="frame-time">0 ms</span>
                    </div>
                    <div class="debug-row">
                        <span>Queue Size:</span>
                        <span id="queue-size">0</span>
                    </div>
                </div>
            </div>
        `;

        // Add debug panel to document
        document.body.appendChild(debugPanel);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .debug-panel {
                position: fixed;
                right: 0;
                top: 0;
                width: 300px;
                height: 100%;
                background: #1a1a1a;
                color: #fff;
                padding: 20px;
                box-shadow: -2px 0 5px rgba(0,0,0,0.2);
                overflow-y: auto;
            }
            .debug-header {
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 20px;
                border-bottom: 1px solid #333;
                padding-bottom: 10px;
            }
            .debug-section {
                margin-bottom: 20px;
                background: #2a2a2a;
                padding: 15px;
                border-radius: 4px;
            }
            .debug-row {
                display: flex;
                justify-content: space-between;
                margin-bottom: 10px;
            }
            .debug-controls {
                display: flex;
                gap: 10px;
                margin-top: 10px;
            }
            .debug-controls button {
                flex: 1;
                padding: 8px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                background: #444;
                color: white;
                transition: background 0.2s;
            }
            .debug-controls button:hover {
                background: #555;
            }
            #main-content {
                margin-right: 300px;
            }
        `;
        document.head.appendChild(style);
    }

    private initializeElements() {
        // Get all required DOM elements
        const elements = {
            verify: 'verifyWasm',
            init: 'initDecoder',
            start: 'startDecoder',
            process: 'processFrame',
            pause: 'pauseDecoder',
            clear: 'clearLog',
            enableDebug: 'enableDebug',
            disableDebug: 'disableDebug',
            playerStatus: 'player-status',
            decoderStatus: 'decoder-status',
            debugMode: 'debug-mode-status',
            frameCount: 'frame-count',
            frameTime: 'frame-time',
            queueSize: 'queue-size'
        };

        // Initialize buttons
        this.buttons = Object.entries(elements).slice(0, 8).reduce((acc, [key, id]) => {
            const element = document.getElementById(id);
            if (!element) throw new Error(`Button ${id} not found`);
            return { ...acc, [key]: element as HTMLButtonElement };
        }, {}) as typeof this.buttons;

        // Initialize status elements
        this.statusElements = {
            player: document.getElementById(elements.playerStatus) || throwError(elements.playerStatus),
            decoder: document.getElementById(elements.decoderStatus) || throwError(elements.decoderStatus),
            debugMode: document.getElementById(elements.debugMode) || throwError(elements.debugMode),
            frameCount: document.getElementById(elements.frameCount) || throwError(elements.frameCount),
            frameTime: document.getElementById(elements.frameTime) || throwError(elements.frameTime),
            queueSize: document.getElementById(elements.queueSize) || throwError(elements.queueSize)
        };
    }

    private setupEventListeners() {
        this.buttons.verify.onclick = () => this.verifyWasm();
        this.buttons.init.onclick = () => this.initializeDecoder();
        this.buttons.start.onclick = () => this.startDecoder();
        this.buttons.process.onclick = () => this.processFrame();
        this.buttons.pause.onclick = () => this.pauseDecoder();
        this.buttons.clear.onclick = () => this.clearLog();
        this.buttons.enableDebug.onclick = () => this.enableDebug();
        this.buttons.disableDebug.onclick = () => this.disableDebug();
    }

    private enableDebug() {
        if (this.decoder) {
            this.decoder.enable_debug_mode();
            this.statusElements.debugMode.textContent = 'Enabled';
            this.startDebugMetrics();
            this.log('info', 'Debug mode enabled');
        }
    }

    private disableDebug() {
        if (this.decoder) {
            this.decoder.disable_debug_mode();
            this.statusElements.debugMode.textContent = 'Disabled';
            this.stopDebugMetrics();
            this.log('info', 'Debug mode disabled');
        }
    }

    private startDebugMetrics() {
        if (this.debugMetricsInterval) return;
        
        this.debugMetricsInterval = window.setInterval(() => {
            if (this.decoder) {
                const status = this.decoder.get_status();
                if (typeof status === 'object') {
                    this.statusElements.frameCount.textContent = status.metrics?.frameCount?.toString() || '0';
                    this.statusElements.frameTime.textContent = `${(status.metrics?.lastFrameTime || 0).toFixed(2)} ms`;
                    this.statusElements.queueSize.textContent = status.queue?.inputQueueSize?.toString() || '0';
                }
            }
        }, 16.67); // ~60fps update rate
    }

    private stopDebugMetrics() {
        if (this.debugMetricsInterval) {
            window.clearInterval(this.debugMetricsInterval);
            this.debugMetricsInterval = null;
        }
    }

    private async checkWebGPUSupport(): Promise<boolean> {
        if (!navigator.gpu) {
            this.log('error', 'WebGPU is not supported in this browser');
            return false;
        }

        try {
            const adapter = await navigator.gpu.requestAdapter({
                powerPreference: 'high-performance'
            });

            if (!adapter) {
                this.log('error', 'No WebGPU adapter found');
                return false;
            }

            const device = await adapter.requestDevice();
            if (!device) {
                this.log('error', 'Failed to get WebGPU device');
                return false;
            }

            this.log('success', 'WebGPU is supported and initialized');
            return true;
        } catch (error) {
            this.log('error', `WebGPU initialization failed: ${error}`);
            return false;
        }
    }
    
    


    private interceptConsole() {
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        console.log = (...args: any[]) => {
            this.log('info', ...args);
            originalLog.apply(console, args);
        };

        console.error = (...args: any[]) => {
            this.log('error', ...args);
            originalError.apply(console, args);
        };

        console.warn = (...args: any[]) => {
            this.log('info', ...args);
            originalWarn.apply(console, args);
        };
    }




    private updateStatus(type: 'player' | 'decoder', status: PlayerStatus | DecoderStatus) {
        const element = this.statusElements[type];
        const statusMap = type === 'player' ? PlayerStatus : DecoderStatus;
        const statusName = statusMap[status];
        
        // Remove all existing status classes
        element.className = 'status-value';
        
        // Add appropriate status class
        switch(status) {
            case 0: element.classList.add('status-idle'); break;
            case 1: element.classList.add('status-ready'); break;
            case 2: element.classList.add('status-playing'); break;
            case 3: element.classList.add('status-paused'); break;
            default: element.classList.add('status-error');
        }
        
        element.textContent = statusName;
    }

    private async verifyWasm() {
        try {
            this.buttons.verify.disabled = true;
            this.log('info', 'Verifying WASM...');
            
            const result = await verifyWasmBuild();
            if (result.success && result.decoder) {
                this.decoder = result.decoder;
                this.buttons.init.disabled = false;
                this.updateStatus('player', PlayerStatus.Ready);
                this.log('success', 'WASM verification successful!');
            } else {
                this.updateStatus('player', PlayerStatus.Idle);
                this.log('error', 'WASM verification failed!');
            }
        } catch (error) {
            this.log('error', `Error: ${error.message}`);
            this.updateStatus('player', PlayerStatus.Idle);
        } finally {
            this.buttons.verify.disabled = false;
        }
    }
    
    
    private async initializeDecoder() {
        try {
            this.buttons.init.disabled = true;
            this.updateStatus('decoder', DecoderStatus.Initializing);
            
            if (!this.decoder || !this.canvas) {
                throw new Error('Decoder or canvas not initialized');
            }
    
            // Check WebGPU support first
            const hasWebGPU = await this.checkWebGPUSupport();
            if (!hasWebGPU) {
                throw new Error('WebGPU not supported or failed to initialize');
            }
    
            // Configure canvas for WebGPU
            this.canvas.width = 640;
            this.canvas.height = 480;
            
            // Enable debug mode using the proper method
            this.decoder.enable_debug_mode();
            
            // Verify debug mode is set
            if (!this.decoder.is_debug_mode()) {
                throw new Error('Failed to enable debug mode');
            }
            
            // Create and set reference data
            const referenceData = this.createReferenceData();
            const refResult = await this.decoder.set_reference_data(referenceData);
            this.log('info', `Reference data set: ${refResult}`);
    
            // Initialize WebGPU context
            const initResult = await this.decoder.initialize_render_context(this.canvas);
            this.log('info', `Render context initialized: ${initResult}`);
    
            this.buttons.start.disabled = false;
            this.updateStatus('decoder', DecoderStatus.Ready);
            this.log('success', 'Decoder initialized successfully in debug mode');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.log('error', `Initialization error: ${errorMessage}`);
            this.updateStatus('decoder', DecoderStatus.Idle);
        } finally {
            this.buttons.init.disabled = false;
        }
    }

    private async processFrame() {
        if (!this.decoder) return;
    
        try {
            // Create frame data
            const frameWidth = 640;
            const frameHeight = 480;
            const channelCount = 4; // RGBA
            const frameData = new Float32Array(frameWidth * frameHeight * channelCount).fill(0.5);
            
            const token: FrameToken = {
                token: frameData,
                frame_index: this.frameCount++
            };
    
            // Process frame
            await this.decoder.process_tokens([token]);
            await this.decoder.process_batch();
    
            // Update metrics if needed
            if (this.frameCount % 60 === 0) {
                const status = await this.decoder.get_status();
                this.log('info', `Frame ${this.frameCount}: ${JSON.stringify(status)}`);
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.log('error', `Process error: ${errorMessage}`);
        }
    }

    private async startDecoderLoop() {
        if (!this.decoder || !this.canvas) return;

        try {
            // Verify we have a canvas
            const status = await this.decoder.get_status();
            if (!status.initialized) {
                throw new Error('Canvas not initialized');
            }

            await this.decoder.start_player_loop();
            this.updateStatus('decoder', DecoderStatus.Playing);
            this.log('success', 'Decoder loop started');

            // Start frame processing
            this.processFrame();
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.log('error', `Start error: ${errorMessage}`);
            this.updateStatus('decoder', DecoderStatus.Ready);
        }
    }
    
    private async startDecoder() {
        try {
            this.buttons.start.disabled = true;
            this.updateStatus('decoder', DecoderStatus.Open);
            
            if (!this.decoder) {
                throw new Error('Decoder not initialized');
            }
    
            // Only check for canvas
            const status = await this.decoder.get_status();
            if (!status.initialized) {
                throw new Error('Canvas not initialized');
            }
    
            // Start the decoder's internal render loop
            await this.decoder.start_player_loop();
            
            // Enable frame processing and pause buttons
            this.buttons.process.disabled = false;
            this.buttons.pause.disabled = false;
            
            // Start our animation loop
            this.startDecoderLoop();
            
            this.log('success', 'Decoder started');
        } catch (error) {
            this.log('error', `Start error: ${error.message}`);
            this.updateStatus('decoder', DecoderStatus.Ready);
        }
    }


    private async pauseDecoder() {
        try {
            this.updateStatus('decoder', DecoderStatus.Pause);
            
            // Stop animation loop
            if (this.animationFrameId !== null) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }

            // Stop decoder's internal render loop
            if (this.decoder) {
                this.decoder.stop_player_loop();
            }

            this.buttons.process.disabled = true;
            this.buttons.pause.disabled = true;
            this.buttons.start.disabled = false;
            
            this.log('info', 'Decoder paused');
        } catch (error) {
            this.log('error', `Pause error: ${error.message}`);
        }
    }

    private createReferenceData(): ReferenceData {
        return {
            features: [
                {
                    tensor: new Float32Array(1 * 128 * 64 * 64).fill(0.5),
                    shape: [1, 128, 64, 64]
                },
                {
                    tensor: new Float32Array(1 * 256 * 32 * 32).fill(0.5),
                    shape: [1, 256, 32, 32]
                },
                {
                    tensor: new Float32Array(1 * 512 * 16 * 16).fill(0.5),
                    shape: [1, 512, 16, 16]
                },
                {
                    tensor: new Float32Array(1 * 512 * 8 * 8).fill(0.5),
                    shape: [1, 512, 8, 8]
                }
            ],
            token: new Float32Array(32).fill(0.1)
        };
    }

    private log(type: 'info' | 'error' | 'success', ...args: any[]) {
        const logDiv = document.getElementById('log')!;
        const line = document.createElement('div');
        line.className = type;
        line.textContent = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' ');
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    private clearLog() {
        this.logInterceptor.clear();

        const logDiv = document.getElementById('log')!;
        logDiv.innerHTML = '';
    }
}

// Initialize when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new TestUI());
} else {
    new TestUI();
}

function throwError(id: string): never {
    throw new Error(`Element ${id} not found`);
}


export { TestUI };
use std::collections::VecDeque;
// use web_sys::Performance;
use super::frame::Frame;

#[derive(Debug, Default)]
pub struct QueueMetrics {
    frames_processed: usize,
    frames_dropped: usize,
    processing_times: Vec<f64>,
    queue_utilization: f32,
    last_process_time: f64,
}

pub struct Queue {
    input_queue: VecDeque<Frame>,
    processing_queue: VecDeque<Frame>,
    output_queue: VecDeque<Frame>,
    max_size: usize,
    batch_size: usize,
    metrics: QueueMetrics,
}

#[derive(Debug)]
pub struct QueueStats {
    pub frames_processed: usize,
    pub frames_dropped: usize,
    pub average_processing_time: f64,
    pub queue_utilization: f32,
    pub input_queue_size: usize,
    pub processing_queue_size: usize,
    pub output_queue_size: usize,
    pub last_process_time: f64,
    pub max_size: usize,
    pub batch_size: usize,
}

impl Queue {
    pub fn new(max_size: usize, batch_size: usize) -> Self {
        Self {
            input_queue: VecDeque::with_capacity(max_size),
            processing_queue: VecDeque::with_capacity(batch_size),
            output_queue: VecDeque::with_capacity(max_size),
            max_size,
            batch_size,
            metrics: QueueMetrics::default(),
        }
    }

    pub fn push(&mut self, frame: Frame) -> bool {
        if self.input_queue.len() < self.max_size {
            self.input_queue.push_back(frame);
            self.update_metrics();
            true
        } else {
            self.metrics.frames_dropped += 1;
            false
        }
    }

    pub fn process_next(&mut self) -> Option<Frame> {
        let start_time = web_sys::window()
            .and_then(|w| w.performance())
            .map(|p| p.now())
            .unwrap_or(0.0);

        let result = if let Some(frame) = self.input_queue.pop_front() {
            self.processing_queue.push_back(frame.clone());
            self.process_frame()
        } else {
            None
        };

        // Record processing time
        if let Some(window) = web_sys::window() {
            if let Some(perf) = window.performance() {
                let processing_time = perf.now() - start_time;
                self.metrics.processing_times.push(processing_time);
                self.metrics.last_process_time = processing_time;

                // Keep only last 100 measurements
                if self.metrics.processing_times.len() > 100 {
                    self.metrics.processing_times.remove(0);
                }
            }
        }

        if result.is_some() {
            self.metrics.frames_processed += 1;
        }

        self.update_metrics();
        result
    }

    fn process_frame(&mut self) -> Option<Frame> {
        self.processing_queue.pop_front().map(|frame| {
            self.output_queue.push_back(frame.clone());
            frame
        })
    }

    pub fn process_batch(&mut self) -> Vec<Frame> {
        let mut batch = Vec::with_capacity(self.batch_size);
        while batch.len() < self.batch_size && !self.input_queue.is_empty() {
            if let Some(frame) = self.process_next() {
                batch.push(frame);
            }
        }
        batch
    }

    // Metrics and Stats Methods
    pub fn get_metrics(&self) -> QueueStats {
        QueueStats {
            frames_processed: self.metrics.frames_processed,
            frames_dropped: self.metrics.frames_dropped,
            average_processing_time: self.get_average_processing_time(),
            queue_utilization: self.metrics.queue_utilization,
            input_queue_size: self.input_queue.len(),
            processing_queue_size: self.processing_queue.len(),
            output_queue_size: self.output_queue.len(),
            last_process_time: self.metrics.last_process_time,
            max_size: self.max_size,
            batch_size: self.batch_size,
        }
    }

    // Getters for bindings.rs
    pub fn get_size(&self) -> usize {
        self.input_queue.len()
    }

    pub fn get_max_size(&self) -> usize {
        self.max_size
    }

    pub fn get_batch_size(&self) -> usize {
        self.batch_size
    }

    pub fn get_queue_sizes(&self) -> (usize, usize, usize) {
        (
            self.input_queue.len(),
            self.processing_queue.len(),
            self.output_queue.len()
        )
    }

    pub fn get_frames_processed(&self) -> usize {
        self.metrics.frames_processed
    }

    pub fn get_frames_dropped(&self) -> usize {
        self.metrics.frames_dropped
    }

    pub fn get_processing_time(&self) -> f64 {
        self.metrics.last_process_time
    }

    // Utility Methods
    fn get_average_processing_time(&self) -> f64 {
        if self.metrics.processing_times.is_empty() {
            0.0
        } else {
            let sum: f64 = self.metrics.processing_times.iter().sum();
            sum / self.metrics.processing_times.len() as f64
        }
    }

    fn update_metrics(&mut self) {
        let total_frames = self.input_queue.len() + self.processing_queue.len() + self.output_queue.len();
        self.metrics.queue_utilization = total_frames as f32 / (self.max_size * 3) as f32;
    }

    // Queue State Methods
    pub fn is_empty(&self) -> bool {
        self.input_queue.is_empty() && 
        self.processing_queue.is_empty() && 
        self.output_queue.is_empty()
    }

    pub fn is_full(&self) -> bool {
        self.input_queue.len() >= self.max_size
    }

    pub fn remaining_capacity(&self) -> usize {
        self.max_size - self.input_queue.len()
    }

    pub fn clear(&mut self) {
        self.input_queue.clear();
        self.processing_queue.clear();
        self.output_queue.clear();
        self.metrics = QueueMetrics::default();
    }
}

impl Drop for Queue {
    fn drop(&mut self) {
        self.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_queue_capacity() {
        let mut queue = Queue::new(5, 2);
        assert_eq!(queue.remaining_capacity(), 5);
        assert_eq!(queue.get_max_size(), 5);
        
        let frame = Frame::new(640, 480);
        assert!(queue.push(frame.clone()));
        assert_eq!(queue.get_size(), 1);
        assert_eq!(queue.remaining_capacity(), 4);
    }

    #[test]
    fn test_batch_processing() {
        let mut queue = Queue::new(10, 3);
        
        for _ in 0..5 {
            let frame = Frame::new(640, 480);
            queue.push(frame);
        }

        let batch = queue.process_batch();
        assert_eq!(batch.len(), 3);
        
        let stats = queue.get_metrics();
        assert_eq!(stats.frames_processed, 3);
        assert_eq!(queue.get_frames_processed(), 3);
    }

    #[test]
    fn test_queue_overflow() {
        let mut queue = Queue::new(2, 1);
        
        let frame1 = Frame::new(640, 480);
        let frame2 = Frame::new(640, 480);
        let frame3 = Frame::new(640, 480);
        
        assert!(queue.push(frame1));
        assert!(queue.push(frame2));
        assert!(!queue.push(frame3));
        assert!(queue.is_full());
        
        let stats = queue.get_metrics();
        assert_eq!(stats.frames_dropped, 1);
        assert_eq!(queue.get_frames_dropped(), 1);
    }

    #[test]
    fn test_queue_metrics() {
        let mut queue = Queue::new(5, 2);
        assert_eq!(queue.get_metrics().queue_utilization, 0.0);
        
        let frame = Frame::new(640, 480);
        queue.push(frame);
        
        let metrics = queue.get_metrics();
        assert!(metrics.queue_utilization > 0.0);
        assert_eq!(metrics.frames_processed, 0);
        assert_eq!(metrics.frames_dropped, 0);
    }
}
use serde::{Serialize, Deserialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct Frame {
    pub width: usize,
    pub height: usize,
    pub data: Vec<u8>,
    pub timestamp: f64,
    pub is_keyframe: bool,
}

impl Frame {
    pub fn new(width: usize, height: usize) -> Self {
        Self {
            width,
            height,
            data: vec![0; width * height * 4],
            timestamp: 0.0,
            is_keyframe: false,
        }
    }

    pub fn set_data(&mut self, data: Vec<u8>) {
        assert_eq!(data.len(), self.width * self.height * 4);
        self.data = data;
    }
}
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct Tensor {
    data: Vec<f32>,
    shape: Vec<usize>,
}

#[wasm_bindgen]
impl Tensor {
    #[wasm_bindgen(constructor)]
    pub fn new(data: Vec<f32>, shape: Vec<usize>) -> Self {
        Self { data, shape }
    }

    pub fn reshape(&mut self, new_shape: Vec<usize>) {
        let total_size: usize = new_shape.iter().product();
        assert_eq!(total_size, self.data.len());
        self.shape = new_shape;
    }

    pub fn get_data(&self) -> Vec<f32> {
        self.data.clone()
    }
}

use wasm_bindgen::prelude::*;
use web_sys::{WebGl2RenderingContext, WebGlProgram, WebGlShader};
use wasm_bindgen::JsCast;

pub struct WebGLDecoder {
    context: WebGl2RenderingContext,
    program: WebGlProgram,
    vertex_shader: WebGlShader,
    fragment_shader: WebGlShader,
}

impl WebGLDecoder {
    pub fn new() -> Result<Self, JsValue> {
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document
            .create_element("canvas")?
            .dyn_into::<web_sys::HtmlCanvasElement>()?;

        let context = canvas
            .get_context("webgl2")?
            .unwrap()
            .dyn_into::<WebGl2RenderingContext>()?;

        // Initialize shaders and program
        let vertex_shader = compile_shader(
            &context,
            WebGl2RenderingContext::VERTEX_SHADER,
            r#"#version 300 es
            in vec4 position;
            void main() {
                gl_Position = position;
            }
            "#,
        )?;

        let fragment_shader = compile_shader(
            &context,
            WebGl2RenderingContext::FRAGMENT_SHADER,
            r#"#version 300 es
            precision highp float;
            out vec4 outColor;
            void main() {
                outColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
            "#,
        )?;

        let program = link_program(&context, &vertex_shader, &fragment_shader)?;

        Ok(Self {
            context,
            program,
            vertex_shader,
            fragment_shader,
        })
    }
}

fn compile_shader(
    context: &WebGl2RenderingContext,
    shader_type: u32,
    source: &str,
) -> Result<WebGlShader, String> {
    let shader = context
        .create_shader(shader_type)
        .ok_or_else(|| String::from("Unable to create shader object"))?;
    context.shader_source(&shader, source);
    context.compile_shader(&shader);

    if context
        .get_shader_parameter(&shader, WebGl2RenderingContext::COMPILE_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(shader)
    } else {
        Err(context
            .get_shader_info_log(&shader)
            .unwrap_or_else(|| String::from("Unknown error creating shader")))
    }
}

fn link_program(
    context: &WebGl2RenderingContext,
    vert_shader: &WebGlShader,
    frag_shader: &WebGlShader,
) -> Result<WebGlProgram, String> {
    let program = context
        .create_program()
        .ok_or_else(|| String::from("Unable to create shader object"))?;

    context.attach_shader(&program, vert_shader);
    context.attach_shader(&program, frag_shader);
    context.link_program(&program);

    if context
        .get_program_parameter(&program, WebGl2RenderingContext::LINK_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(program)
    } else {
        Err(context
            .get_program_info_log(&program)
            .unwrap_or_else(|| String::from("Unknown error creating program")))
    }
}
pub mod frame;
pub mod queue;
pub mod tensor;
pub mod webgl;

pub use frame::Frame;
pub use queue::Queue;
pub use tensor::Tensor;
pub use webgl::WebGLDecoder;

use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};
use web_sys::WorkerGlobalScope;

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum DecoderStatus {
    Idle = 0,
    Initializing = 1,
    Inited = 2,
    Ready = 3,
    Open = 4,
    Pause = 5,
    Closed = 6,
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum DecodeMessage {
    DecoderCreated = 0,
    DecoderInit = 1,
    DecoderInited = 2,
    WasmLoaded = 3,
    DecoderReady = 4,
    DecoderOpenError = 5,
    DecoderStart = 6,
    DecoderStarted = 7,
    DecoderPause = 8,
    DecoderPaused = 9,
    DecoderClose = 10,
    DecoderClosed = 11,
    DecodeVideoBuffer = 12,
    DecodedVideoFrame = 13,
}

#[wasm_bindgen]
pub struct DecoderWorker {
    status: DecoderStatus,
    decoder: IMFDecoder,
    scope: WorkerGlobalScope,
}

#[wasm_bindgen]
impl DecoderWorker {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Result<DecoderWorker, JsValue> {
        let scope = js_sys::global().unchecked_into::<WorkerGlobalScope>();
        let decoder = IMFDecoder::new(1920, 1080)?;
        
        let worker = DecoderWorker {
            status: DecoderStatus::Idle,
            decoder,
            scope,
        };

        worker.post_message(DecodeMessage::DecoderCreated);
        Ok(worker)
    }

    fn post_message(&self, msg: DecodeMessage) {
        let msg_val = serde_wasm_bindgen::to_value(&msg).unwrap();
        self.scope.post_message(&msg_val).unwrap();
    }

    #[wasm_bindgen]
    pub fn initialize(&mut self) -> Result<(), JsValue> {
        self.status = DecoderStatus::Initializing;
        self.post_message(DecodeMessage::DecoderInit);
        
        // Initialize decoder
        self.decoder.test();
        
        self.status = DecoderStatus::Inited;
        self.post_message(DecodeMessage::DecoderInited);
        Ok(())
    }

    #[wasm_bindgen]
    pub fn start(&mut self) -> Result<(), JsValue> {
        if self.status != DecoderStatus::Ready {
            return Err(JsValue::from_str("Decoder not ready"));
        }

        self.status = DecoderStatus::Open;
        self.post_message(DecodeMessage::DecoderStarted);
        Ok(())
    }

    #[wasm_bindgen]
    pub fn pause(&mut self) -> Result<(), JsValue> {
        if self.status != DecoderStatus::Open {
            return Err(JsValue::from_str("Decoder not running"));
        }

        self.status = DecoderStatus::Pause;
        self.post_message(DecodeMessage::DecoderPaused);
        Ok(())
    }

    #[wasm_bindgen]
    pub fn process_frame(&mut self, frame_data: JsValue) -> Result<(), JsValue> {
        if self.status != DecoderStatus::Open {
            return Err(JsValue::from_str("Decoder not running"));
        }

        self.decoder.process_tokens(frame_data)?;
        self.decoder.process_batch()?;
        
        self.post_message(DecodeMessage::DecodedVideoFrame);
        Ok(())
    }
}
pub struct Metrics {
    frame_times: Vec<f64>,
    queue_sizes: Vec<usize>,
    processing_times: Vec<f64>,
    window_size: usize,
}

impl Metrics {
    pub fn new() -> Self {
        Self {
            frame_times: Vec::new(),
            queue_sizes: Vec::new(),
            processing_times: Vec::new(),
            window_size: 60,
        }
    }

    pub fn record_frame_time(&mut self, time: f64) {
        self.frame_times.push(time);
        if self.frame_times.len() > self.window_size {
            self.frame_times.remove(0);
        }
    }

    pub fn record_queue_size(&mut self, size: usize) {
        self.queue_sizes.push(size);
        if self.queue_sizes.len() > self.window_size {
            self.queue_sizes.remove(0);
        }
    }

    pub fn record_processing_time(&mut self, time: f64) {
        self.processing_times.push(time);
        if self.processing_times.len() > self.window_size {
            self.processing_times.remove(0);
        }
    }
}
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct Memory {
    allocated: AtomicUsize,
    peak: AtomicUsize,
}

impl Memory {
    pub fn new() -> Self {
        Self {
            allocated: AtomicUsize::new(0),
            peak: AtomicUsize::new(0),
        }
    }

    pub fn allocate(&self, size: usize) {
        let new_allocated = self.allocated.fetch_add(size, Ordering::SeqCst) + size;
        let mut peak = self.peak.load(Ordering::SeqCst);
        while new_allocated > peak {
            match self.peak.compare_exchange(
                peak,
                new_allocated,
                Ordering::SeqCst,
                Ordering::SeqCst,
            ) {
                Ok(_) => break,
                Err(x) => peak = x,
            }
        }
    }

    pub fn deallocate(&self, size: usize) {
        self.allocated.fetch_sub(size, Ordering::SeqCst);
    }
}
pub mod memory;
pub mod metrics;

pub use memory::Memory;
pub use metrics::Metrics;
use wasm_bindgen::prelude::*;
use web_sys::{HtmlCanvasElement, CanvasRenderingContext2d, ImageData};
use wasm_bindgen::JsCast;
use serde::{Serialize, Deserialize};
use log::{info, error, debug};
use wasm_bindgen::Clamped;
use crate::decoder::{Frame, Queue as FrameQueue};
use std::cell::RefCell;
use std::rc::Rc;
use web_sys::window;
use wasm_bindgen::JsValue;


// Add this type alias to make the closure type more readable
type AnimationCallback = Rc<RefCell<Option<Closure<dyn FnMut()>>>>;

#[wasm_bindgen]
pub struct IMFDecoder {
    width: u32,
    height: u32,
    frame_queue: FrameQueue,
    canvas: Option<HtmlCanvasElement>,
    context: Option<CanvasRenderingContext2d>,
    animation_id: Option<i32>,
    reference_data: Option<ReferenceData>,
    diagnostic_mode: bool,
    debug_mode: bool,
    frame_count: RefCell<u64>,
    last_frame_time: RefCell<f64>,
    animation_callback: AnimationCallback,

}

struct AnimationFrame {
    closure: Closure<dyn FnMut()>,
    id: i32,
}
impl Drop for AnimationFrame {
    fn drop(&mut self) {
        if let Some(window) = web_sys::window() {
            let _ = window.cancel_animation_frame(self.id);
        }
    }
}


#[derive(Serialize, Deserialize, Debug)]
struct ReferenceFeature {
    tensor: Vec<f32>,
    shape: Vec<usize>,
}

#[derive(Serialize, Deserialize, Debug)]
struct ReferenceData {
    features: Vec<ReferenceFeature>,
    token: Vec<f32>,
}

#[derive(Serialize, Deserialize)]
struct FrameToken {
    token: Vec<f32>,
    frame_index: usize,
}

#[wasm_bindgen]
impl IMFDecoder {

    
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Result<IMFDecoder, JsValue> {
        let _ = console_error_panic_hook::set_once();
        let _ = wasm_logger::init(wasm_logger::Config::default());
        
        info!("Creating IMFDecoder with dimensions {}x{}", width, height);

        Ok(Self {
            width,
            height,
            frame_queue: FrameQueue::new(10000, 4),
            canvas: None,
            context: None,
            animation_id: None,
            reference_data: None,
            diagnostic_mode: false,
            debug_mode: false,
            frame_count: RefCell::new(0),
            last_frame_time: RefCell::new(0.0),
            animation_callback: Rc::new(RefCell::new(None)),
        })
    }

    #[wasm_bindgen(getter)]
    pub fn debug_mode(&self) -> bool {
        self.debug_mode
    }

    #[wasm_bindgen(setter)]
    pub fn set_debug_mode(&mut self, value: bool) {
        self.debug_mode = value;
        info!("Debug mode set to: {}", value);
    }

    // Method to check debug status - useful for verification
    #[wasm_bindgen]
    pub fn is_debug_mode(&self) -> bool {
        self.debug_mode
    }

    #[wasm_bindgen]
    pub fn enable_debug_mode(&mut self) {
        self.debug_mode = true;
        info!("Debug mode enabled");
    }

    #[wasm_bindgen]
    pub fn disable_debug_mode(&mut self) {
        self.debug_mode = false;
        info!("Debug mode disabled");
    }
 
    // pub fn start_player_loop(&mut self) -> Result<(), JsValue> {
    //     debug!("Starting player loop");
        
    //     self.stop_player_loop();

    //     let window = web_sys::window()
    //         .ok_or_else(|| JsValue::from_str("No window found"))?;
    //     let window = Rc::new(window);
    //     let window_clone = window.clone();

    //     let this = Rc::new(RefCell::new(self));
    //     let this_clone = this.clone();
        
    //     // Create the animation closure
    //     let closure = Rc::new(RefCell::new(None));
    //     let closure_clone = closure.clone();

    //     *closure.borrow_mut() = Some(Closure::wrap(Box::new(move || {
    //         let mut this = this_clone.borrow_mut();
    //         if let Err(e) = this.render_frame() {
    //             error!("Render error: {:?}", e);
    //             return;
    //         }

    //         // Update frame count
    //         *this.frame_count.borrow_mut() += 1;

    //         // Request next frame
    //         if let Some(ref callback) = *closure_clone.borrow() {
    //             if let Ok(id) = window_clone.request_animation_frame(callback.as_ref().unchecked_ref()) {
    //                 this.animation_id = Some(id);
    //             }
    //         }
    //     }) as Box<dyn FnMut()>));

    //     // Start the animation
    //     if let Some(ref callback) = *closure.borrow() {
    //         let id = window.request_animation_frame(callback.as_ref().unchecked_ref())?;
    //         let mut this = this.borrow_mut();
    //         this.animation_id = Some(id);
    //         this.animation_closure = Some(closure);
    //     }

    //     Ok(())
    // }
    pub fn start_player_loop(&self) -> Result<(), JsValue> {
        let window = window().expect("no global `window` exists");
        let window = Rc::new(window);
        let window_clone = window.clone();
    
        let callback_ref = self.animation_callback.clone();
        let context = self.context.clone();
    
        // Create a simple animation closure
        let new_callback = Closure::wrap(Box::new(move || {
            if let Some(ref ctx) = context {
                // Clear and draw something
                ctx.clear_rect(0.0, 0.0, 640.0, 480.0);
                
                // Use the non-deprecated way to set fill style
                let style = JsValue::from_str("blue");
                ctx.set_fill_style(&style);
                
                ctx.fill_rect(50.0, 50.0, 100.0, 100.0);
            }
    
            // Request next frame using the cloned window
            if let Some(ref callback) = *callback_ref.borrow() {
                let _ = window_clone.request_animation_frame(callback.as_ref().unchecked_ref());
            }
        }) as Box<dyn FnMut()>);
    
        // Store the new callback
        *self.animation_callback.borrow_mut() = Some(new_callback);
    
        // Start the animation with the original window
        if let Some(ref callback) = *self.animation_callback.borrow() {
            window.request_animation_frame(callback.as_ref().unchecked_ref())?;
        }
    
        Ok(())
    }

    fn generate_debug_pattern(&self, frame_data: &mut [u8]) {
        let time = (*self.frame_count.borrow() as f64) * 0.05;
        
        for y in 0..self.height {
            for x in 0..self.width {
                let idx = ((y * self.width + x) * 4) as usize;
                
                // Create animated color pattern
                let r = ((((x as f64) * 0.01 + time).sin() + 1.0) * 127.5) as u8;
                let g = ((((y as f64) * 0.01 + time).cos() + 1.0) * 127.5) as u8;
                let b = (((((x + y) as f64) * 0.01 + time).sin() + 1.0) * 127.5) as u8;
                
                frame_data[idx] = r;     // R
                frame_data[idx + 1] = g; // G
                frame_data[idx + 2] = b; // B
                frame_data[idx + 3] = 255; // A
            }
        }
    }


    #[wasm_bindgen]
    pub async fn initialize_render_context(&mut self, canvas: HtmlCanvasElement) -> Result<String, JsValue> {
        // Store canvas dimensions
        self.width = canvas.width();
        self.height = canvas.height();
        
        // Get and store 2D context
        let context = canvas
            .get_context("2d")?
            .unwrap()
            .dyn_into::<CanvasRenderingContext2d>()?;

        // Store both canvas and context
        self.canvas = Some(canvas);
        self.context = Some(context);
        
        info!("2D context initialized with canvas dimensions {}x{}", self.width, self.height);
        Ok("2D context initialized successfully".to_string())
    }

    #[wasm_bindgen]
    pub fn get_capabilities(&self) -> JsValue {
        let capabilities = js_sys::Object::new();
        
        js_sys::Reflect::set(
            &capabilities,
            &"version".into(),
            &"1.0.0".into()
        ).unwrap();

        js_sys::Reflect::set(
            &capabilities,
            &"dimensions".into(),
            &format!("{}x{}", self.width, self.height).into()
        ).unwrap();

        // Create features array
        let features = js_sys::Array::new();
        features.push(&"WebGPU".into());
        features.push(&"Tensor Processing".into());
        features.push(&"Frame Queue".into());

        js_sys::Reflect::set(
            &capabilities,
            &"features".into(),
            &features
        ).unwrap();

        // Create methods array
        let methods = js_sys::Array::new();
        methods.push(&"test".into());
        methods.push(&"start_player_loop".into());
        methods.push(&"stop_player_loop".into());
        methods.push(&"set_reference_data".into());
        methods.push(&"process_tokens".into());
        methods.push(&"process_batch".into());

        js_sys::Reflect::set(
            &capabilities,
            &"methods".into(),
            &methods
        ).unwrap();

        // Add performance capabilities
        let performance = js_sys::Object::new();
        js_sys::Reflect::set(
            &performance,
            &"maxQueueSize".into(),
            &(60_i32).into()
        ).unwrap();
        js_sys::Reflect::set(
            &performance,
            &"batchSize".into(),
            &(4_i32).into()
        ).unwrap();
        js_sys::Reflect::set(
            &performance,
            &"targetFPS".into(),
            &(60_i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &capabilities,
            &"performance".into(),
            &performance
        ).unwrap();

        // Add diagnostic info
        let diagnostics = js_sys::Object::new();

        js_sys::Reflect::set(
            &diagnostics,
            &"diagnosticMode".into(),
            &self.diagnostic_mode.into()
        ).unwrap();

        js_sys::Reflect::set(
            &capabilities,
            &"diagnostics".into(),
            &diagnostics
        ).unwrap();

        js_sys::Reflect::set(
            &diagnostics,
            &"frameCount".into(),
            &JsValue::from_f64(*self.frame_count.borrow() as f64)
        ).unwrap();

        capabilities.into()
    }

    #[wasm_bindgen]
    pub fn test(&self) -> String {
        let msg = format!("IMFDecoder working! Size: {}x{}", self.width, self.height);
        info!("{}", msg);
        msg
    }

    #[wasm_bindgen]
    pub fn get_status(&self) -> JsValue {
        let status = js_sys::Object::new();

        js_sys::Reflect::set(
            &status,
            &"initialized".into(),
            &(self.canvas.is_some() && self.context.is_some()).into()
        ).unwrap();

        js_sys::Reflect::set(
            &status,
            &"running".into(),
            &self.animation_id.is_some().into()
        ).unwrap();

        // Performance metrics
        let metrics = js_sys::Object::new();
        js_sys::Reflect::set(
            &metrics,
            &"frameCount".into(),
            &JsValue::from_f64(*self.frame_count.borrow() as f64)
        ).unwrap();
        
   
        js_sys::Reflect::set(&status, &"metrics".into(), &metrics).unwrap();
        


        // Queue status using correct method names
        let queue_status = js_sys::Object::new();
        let (input_size, processing_size, output_size) = self.frame_queue.get_queue_sizes();
        
        js_sys::Reflect::set(
            &queue_status,
            &"inputQueueSize".into(),
            &(input_size as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"processingQueueSize".into(),
            &(processing_size as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"outputQueueSize".into(),
            &(output_size as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"maxSize".into(),
            &(self.frame_queue.get_max_size() as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"batchSize".into(),
            &(self.frame_queue.get_batch_size() as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"isFull".into(),
            &self.frame_queue.is_full().into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"isEmpty".into(),
            &self.frame_queue.is_empty().into()
        ).unwrap();

        // Add additional metrics
        js_sys::Reflect::set(
            &queue_status,
            &"framesProcessed".into(),
            &(self.frame_queue.get_frames_processed() as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"framesDropped".into(),
            &(self.frame_queue.get_frames_dropped() as i32).into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"processingTime".into(),
            &self.frame_queue.get_processing_time().into()
        ).unwrap();

        // Add queue stats
        let stats = self.frame_queue.get_metrics();
        let queue_metrics = js_sys::Object::new();
        
        js_sys::Reflect::set(
            &queue_metrics,
            &"averageProcessingTime".into(),
            &stats.average_processing_time.into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_metrics,
            &"queueUtilization".into(),
            &stats.queue_utilization.into()
        ).unwrap();

        js_sys::Reflect::set(
            &queue_status,
            &"metrics".into(),
            &queue_metrics
        ).unwrap();

        js_sys::Reflect::set(&status, &"queue".into(), &queue_status).unwrap();

        // Debug info
        let debug = js_sys::Object::new();
        js_sys::Reflect::set(
            &debug,
            &"diagnosticMode".into(),
            &self.diagnostic_mode.into()
        ).unwrap();

        js_sys::Reflect::set(&status, &"debug".into(), &debug).unwrap();

        status.into()
    }

    
    #[wasm_bindgen]
    pub fn stop_player_loop(&mut self) {
        // Drop the animation callback
        self.animation_callback.borrow_mut().take();
        debug!("Animation stopped");
    }

    #[wasm_bindgen(getter)]
    pub fn diagnostic_mode(&self) -> bool {
        self.diagnostic_mode
    }

    #[wasm_bindgen(setter)]
    pub fn set_diagnostic_mode(&mut self, value: bool) {
        self.diagnostic_mode = value;
        info!("Diagnostic mode set to: {}", value);
    }

    #[wasm_bindgen]
    pub fn set_reference_data(&mut self, data: JsValue) -> Result<String, JsValue> {
        info!("Setting reference data...");
        
        let ref_data: ReferenceData = serde_wasm_bindgen::from_value(data)?;
        
        let expected_shapes = vec![
            vec![1, 128, 64, 64],
            vec![1, 256, 32, 32],
            vec![1, 512, 16, 16],
            vec![1, 512, 8, 8],
        ];

        for (feature, expected) in ref_data.features.iter().zip(expected_shapes.iter()) {
            if feature.shape != *expected {
                return Err(JsValue::from_str(&format!(
                    "Invalid tensor shape: {:?}, expected: {:?}", 
                    feature.shape, expected
                )));
            }
        }

        if ref_data.token.len() != 32 {
            return Err(JsValue::from_str("Reference token must be length 32"));
        }

        self.reference_data = Some(ref_data);
        Ok("Reference data set successfully".to_string())
    }

  
    #[wasm_bindgen]
    pub fn process_tokens(&mut self, tokens: JsValue) -> Result<String, JsValue> {
        info!("Starting token processing...");
        
        let frame_tokens: Vec<FrameToken> = match serde_wasm_bindgen::from_value::<Vec<FrameToken>>(tokens) {
            Ok(t) => {
                info!("Successfully deserialized {} tokens", t.len());
                t
            },
            Err(e) => {
                error!("Failed to deserialize tokens: {:?}", e);
                return Err(JsValue::from_str(&format!("Token deserialization failed: {:?}", e)));
            }
        };
        
        let token_count = frame_tokens.len();
        info!("Processing {} tokens", token_count);
        
        for (idx, token) in frame_tokens.iter().enumerate() {
            info!("Processing token {}/{} with frame index {}", idx + 1, token_count, token.frame_index);
            debug!("Token data length: {}", token.token.len());
            
            let mut frame = Frame::new(self.width as usize, self.height as usize);
            let frame_data: Vec<u8> = token.token.iter().map(|&x| x as u8).collect();
            debug!("Converted frame data length: {}", frame_data.len());
            
            frame.set_data(frame_data);
            debug!("Frame data set, pushing to queue");
            
            self.frame_queue.push(frame);
        }
        
        info!("Token processing complete");
        Ok(format!("Successfully processed {} tokens", token_count))
    }



    fn render_frame(&mut self) -> Result<(), JsValue> {
        debug!("Starting render frame");
        
        if let Some(context) = &self.context {
            let width = self.width;
            let height = self.height;

            // If in debug mode, generate a test pattern
            if self.debug_mode {
                let mut data = vec![0u8; (width * height * 4) as usize];
                self.generate_debug_pattern(&mut data);

                let image_data = ImageData::new_with_u8_clamped_array_and_sh(
                    Clamped(&data),
                    width,
                    height
                )?;

                context.put_image_data(&image_data, 0.0, 0.0)?;
            } else {
                // Regular frame processing from queue
                if let Some(frame) = self.frame_queue.process_next() {
                    let image_data = ImageData::new_with_u8_clamped_array_and_sh(
                        Clamped(&frame.data),
                        width,
                        height
                    )?;
                    context.put_image_data(&image_data, 0.0, 0.0)?;
                }
            }

            if self.diagnostic_mode {
                self.update_metrics();
            }
        }

        Ok(())
    }

    fn update_metrics(&self) {
        // if let Some(window) = web_sys::window() {
        //     if let Some(performance) = window.performance() {
        //         let now = performance.now();
        //         // let frame_time = now - self.last_frame_time.get();
        //         // self.last_frame_time.set(now);

        //         let fps = 1000.0 / frame_time;
        //         let frame_count = self.frame_count.get();
                
        //         info!("Frame {} metrics:", frame_count);
        //         debug!("  - Frame time: {:.2}ms", frame_time);
        //         debug!("  - FPS: {:.2}", fps);
        //         debug!("  - Queue status: {:?}", self.frame_queue.get_queue_sizes());
                
        //         if frame_count % 60 == 0 {
        //             info!("Performance report:");
        //             info!("  - Average FPS: {:.2}", fps);
        //             info!("  - Frame time: {:.2}ms", frame_time);
        //             info!("  - Frames processed: {}", frame_count);
        //         }
        //     }
        // }
    }

    #[wasm_bindgen]
    pub fn process_batch(&mut self) -> Result<String, JsValue> {
        info!("Processing batch...");
        let processed = self.frame_queue.process_batch();
        Ok(format!("Processed batch: {} frames", processed.len()))
    }

    #[wasm_bindgen]
    pub fn get_reference_status(&self) -> String {
        match &self.reference_data {
            Some(ref_data) => format!(
                "Reference data loaded: {} features",
                ref_data.features.len()
            ),
            None => "No reference data loaded".to_string(),
        }
    }
}

impl Drop for IMFDecoder {
    fn drop(&mut self) {
        self.stop_player_loop();
    }
}

// Helper struct for passing tensor data between Rust and JavaScript
#[derive(Serialize, Deserialize)]
struct TensorData {
    data: Vec<f32>,
    shape: Vec<usize>,
}

// JavaScript bindings for IMF operations
#[wasm_bindgen]
extern "C" {
    // Define JavaScript functions that will be called from Rust
    #[wasm_bindgen(js_namespace = tf, js_name = tensor)]
    fn create_tensor(data: &[f32], shape: &[usize]) -> JsValue;

    #[wasm_bindgen(js_namespace = tf, js_name = tidy)]
    fn tensor_tidy(callback: &Closure<dyn FnMut() -> JsValue>) -> JsValue;
}
pub mod bindings;

// Re-export the bindings
pub use bindings::*;
use wasm_bindgen::prelude::*;
use web_sys::{Worker, MessageEvent};

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum PlayerStatus {
    Idle = 0,
    Ready = 1,
    Playing = 2,
    Pause = 3,
    Destroyed = 4,
}

#[wasm_bindgen]
pub struct Player {
    status: PlayerStatus,
    worker: Option<Worker>,
    width: u32,
    height: u32,
}

#[wasm_bindgen]
impl Player {
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Result<Player, JsValue> {
        let worker = Worker::new("./decoder.worker.js")?;
        
        let player = Player {
            status: PlayerStatus::Idle,
            worker: Some(worker),
            width,
            height,
        };

        Ok(player)
    }

    #[wasm_bindgen]
    pub fn initialize(&mut self) -> Result<(), JsValue> {
        if let Some(worker) = &self.worker {
            let msg = JsValue::from_str("initialize");
            worker.post_message(&msg)?;
            self.status = PlayerStatus::Ready;
        }
        Ok(())
    }

    #[wasm_bindgen]
    pub fn start(&mut self) -> Result<(), JsValue> {
        if self.status != PlayerStatus::Ready {
            return Err(JsValue::from_str("Player not ready"));
        }

        if let Some(worker) = &self.worker {
            let msg = JsValue::from_str("start");
            worker.post_message(&msg)?;
            self.status = PlayerStatus::Playing;
        }
        Ok(())
    }

    #[wasm_bindgen]
    pub fn pause(&mut self) -> Result<(), JsValue> {
        if self.status != PlayerStatus::Playing {
            return Err(JsValue::from_str("Player not playing"));
        }

        if let Some(worker) = &self.worker {
            let msg = JsValue::from_str("pause");
            worker.post_message(&msg)?;
            self.status = PlayerStatus::Pause;
        }
        Ok(())
    }
}
use wasm_bindgen::prelude::*;

pub mod decoder;
pub mod utils;
pub mod wasm;

// Re-export for JavaScript
pub use wasm::bindings::*;

// Initialize panic hook
#[wasm_bindgen(start)]
pub fn start() {
    std::panic::set_hook(Box::new(console_error_panic_hook::hook));
}
.
├── benches
│   └── decode_bench.rs
├── Cargo.lock
├── Cargo.toml
├── context.sh
├── dir.txt
├── eslint-config.json
├── index.html
├── js
│   ├── decoder
│   ├── index.ts
│   ├── log-interceptor.ts
│   ├── tfjs_bindings.js
│   ├── types
│   └── utils
├── js.combined
├── package.json
├── package-lock.json
├── pnpm-lock.yaml
├── project.txt
├── README.md
├── run.sh
├── shaders
│   └── shader.wgsl
├── src
│   ├── decoder
│   ├── lib.rs
│   ├── player.rs
│   ├── utils
│   └── wasm
├── src.combined
├── styles
│   └── styles.css
├── tests
│   └── decoder_tests.rs
├── tree.txt
├── tsconfig.json
├── webpack.config.js
└── webpack.worker.config.js

12 directories, 27 files
const path = require('path');
const WasmPackPlugin = require("@wasm-tool/wasm-pack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    entry: {
        main: './js/index.ts',
        worker: './js/decoder/worker.ts'
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js',
        clean: true,
        webassemblyModuleFilename: "[hash].module.wasm"
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.js', '.jsx', '.wasm', '.css'],
        alias: {
            '@': path.resolve(__dirname, 'js'),
            '@pkg': path.resolve(__dirname, 'pkg')
        }
    },
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                use: {
                    loader: 'ts-loader',
                    options: {
                        transpileOnly: true
                    }
                },
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader'],
                sideEffects: true
            }
        ]
    },
    experiments: {
        asyncWebAssembly: true,
        topLevelAwait: true
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './index.html',  // Updated path
            filename: 'index.html',
        }),
        new WasmPackPlugin({
            crateDirectory: path.resolve(__dirname, "."),
            outDir: 'pkg',
            extraArgs: '--target web'
        }),
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: 'styles',  // Just the styles directory
                    to: 'styles',
                    noErrorOnMissing: true
                }
            ]
        })
    ],
    devServer: {
        static: {
            directory: path.join(__dirname, 'dist'),
            watch: true,
            serveIndex: true
        },
        devMiddleware: {
            mimeTypes: {
                'css': 'text/css'
            }
        },
        hot: true,
        compress: true,
        port: 'auto',
        historyApiFallback: true,
        headers: {
            'Access-Control-Allow-Origin': '*'
        }
    }
};{
  "name": "imf-decoder",
  "version": "1.0.0",
  "scripts": {
    "clean": "rm -rf dist pkg",
    "build:wasm": "wasm-pack build --target web",
    "build:ts": "webpack --mode production",
    "build": "pnpm run clean && pnpm run build:wasm && pnpm run build:ts",
    "start": "pnpm run build:wasm && webpack serve --mode development --open"
  },
  "dependencies": {
    "@tensorflow/tfjs": "^4.4.0"
  },
  "devDependencies": {
    "@babel/core": "^7.23.0",
    "@babel/preset-env": "^7.22.20",
    "@types/node": "^20.8.0",
    "@types/webpack": "^5.28.0",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "@wasm-tool/wasm-pack-plugin": "^1.6.0",
    "babel-loader": "^9.1.3",
    "copy-webpack-plugin": "^11.0.0",
    "css-loader": "^6.11.0",
    "html-webpack-plugin": "^5.5.0",
    "style-loader": "^3.3.4",
    "ts-loader": "^9.4.4",
    "typescript": "^5.2.2",
    "webpack": "^5.75.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.11.1"
  }
}